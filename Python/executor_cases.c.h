// This file is generated by Tools/cases_generator/tier2_generator.py
// from:
//   Python/bytecodes.c
// Do not edit!

#ifdef TIER_ONE
    #error "This file is for Tier 2 only"
#endif
#define TIER_TWO 2

        case _NOP_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _NOP_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _NOP_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _NOP_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CHECK_PERIODIC_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _Py_CHECK_EMSCRIPTEN_SIGNALS_PERIODICALLY();
            QSBR_QUIESCENT_STATE(tstate);
            if (_Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker) & _PY_EVAL_EVENTS_MASK) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                int err = _Py_HandlePending(tstate);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (err != 0) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_PERIODIC_IF_NOT_YIELD_FROM_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            oparg = CURRENT_OPARG();
            if ((oparg & RESUME_OPARG_LOCATION_MASK) < RESUME_AFTER_YIELD_FROM) {
                _Py_CHECK_EMSCRIPTEN_SIGNALS_PERIODICALLY();
                QSBR_QUIESCENT_STATE(tstate);
                if (_Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker) & _PY_EVAL_EVENTS_MASK) {
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    int err = _Py_HandlePending(tstate);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                    if (err != 0) {
                        SET_CURRENT_CACHED_VALUES(0);
                        JUMP_TO_ERROR();
                    }
                }
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        /* _QUICKEN_RESUME is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        /* _LOAD_BYTECODE is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _RESUME_CHECK_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            #if defined(__EMSCRIPTEN__)
            if (_Py_emscripten_signal_clock == 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _Py_emscripten_signal_clock -= Py_EMSCRIPTEN_SIGNAL_HANDLING;
            #endif
            uintptr_t eval_breaker = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker);
            uintptr_t version = FT_ATOMIC_LOAD_UINTPTR_ACQUIRE(_PyFrame_GetCode(frame)->_co_instrumentation_version);
            assert((version & _PY_EVAL_EVENTS_MASK) == 0);
            if (eval_breaker != version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            if (frame->tlbc_index !=
                    ((_PyThreadStateImpl *)tstate)->tlbc_index) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _RESUME_CHECK_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            #if defined(__EMSCRIPTEN__)
            if (_Py_emscripten_signal_clock == 0) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _Py_emscripten_signal_clock -= Py_EMSCRIPTEN_SIGNAL_HANDLING;
            #endif
            uintptr_t eval_breaker = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker);
            uintptr_t version = FT_ATOMIC_LOAD_UINTPTR_ACQUIRE(_PyFrame_GetCode(frame)->_co_instrumentation_version);
            assert((version & _PY_EVAL_EVENTS_MASK) == 0);
            if (eval_breaker != version) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            if (frame->tlbc_index !=
                    ((_PyThreadStateImpl *)tstate)->tlbc_index) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _RESUME_CHECK_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            #if defined(__EMSCRIPTEN__)
            if (_Py_emscripten_signal_clock == 0) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _Py_emscripten_signal_clock -= Py_EMSCRIPTEN_SIGNAL_HANDLING;
            #endif
            uintptr_t eval_breaker = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker);
            uintptr_t version = FT_ATOMIC_LOAD_UINTPTR_ACQUIRE(_PyFrame_GetCode(frame)->_co_instrumentation_version);
            assert((version & _PY_EVAL_EVENTS_MASK) == 0);
            if (eval_breaker != version) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            if (frame->tlbc_index !=
                    ((_PyThreadStateImpl *)tstate)->tlbc_index) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _RESUME_CHECK_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            #if defined(__EMSCRIPTEN__)
            if (_Py_emscripten_signal_clock == 0) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _Py_emscripten_signal_clock -= Py_EMSCRIPTEN_SIGNAL_HANDLING;
            #endif
            uintptr_t eval_breaker = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker);
            uintptr_t version = FT_ATOMIC_LOAD_UINTPTR_ACQUIRE(_PyFrame_GetCode(frame)->_co_instrumentation_version);
            assert((version & _PY_EVAL_EVENTS_MASK) == 0);
            if (eval_breaker != version) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            if (frame->tlbc_index !=
                    ((_PyThreadStateImpl *)tstate)->tlbc_index) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        /* _MONITOR_RESUME is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _LOAD_FAST_CHECK_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            _PyStackRef value_s = GETLOCAL(oparg);
            if (PyStackRef_IsNull(value_s)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyEval_FormatExcCheckArg(tstate, PyExc_UnboundLocalError,
                    UNBOUNDLOCAL_ERROR_MSG,
                    PyTuple_GetItem(_PyFrame_GetCode(frame)->co_localsplusnames, oparg)
                );
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            value = PyStackRef_DUP(value_s);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_0_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 0;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_0_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 0;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_0_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 0;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_1_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 1;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_1_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 1;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_1_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 1;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_2_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 2;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_2_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 2;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_2_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 2;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_3_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 3;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_3_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 3;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_3_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 3;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_4_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 4;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_4_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 4;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_4_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 4;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_5_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 5;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_5_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 5;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_5_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 5;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_6_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 6;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_6_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 6;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_6_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 6;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_7_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 7;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_7_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 7;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_7_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 7;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_DUP(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_BORROW_0_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 0;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_BORROW_0_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 0;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_BORROW_0_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 0;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_BORROW_1_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 1;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_BORROW_1_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 1;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_BORROW_1_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 1;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_BORROW_2_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 2;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_BORROW_2_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 2;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_BORROW_2_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 2;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_BORROW_3_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 3;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_BORROW_3_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 3;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_BORROW_3_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 3;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_BORROW_4_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 4;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_BORROW_4_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 4;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_BORROW_4_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 4;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_BORROW_5_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 5;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_BORROW_5_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 5;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_BORROW_5_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 5;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_BORROW_6_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 6;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_BORROW_6_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 6;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_BORROW_6_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 6;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_BORROW_7_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = 7;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_BORROW_7_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 7;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_BORROW_7_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = 7;
            assert(oparg == CURRENT_OPARG());
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_BORROW_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_BORROW_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_BORROW_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            assert(!PyStackRef_IsNull(GETLOCAL(oparg)));
            value = PyStackRef_Borrow(GETLOCAL(oparg));
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_FAST_AND_CLEAR_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            value = GETLOCAL(oparg);
            GETLOCAL(oparg) = PyStackRef_NULL;
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_FAST_AND_CLEAR_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            value = GETLOCAL(oparg);
            GETLOCAL(oparg) = PyStackRef_NULL;
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_FAST_AND_CLEAR_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            value = GETLOCAL(oparg);
            GETLOCAL(oparg) = PyStackRef_NULL;
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_CONST_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            PyObject *obj = GETITEM(FRAME_CO_CONSTS, oparg);
            value = PyStackRef_FromPyObjectBorrow(obj);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_CONST_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            PyObject *obj = GETITEM(FRAME_CO_CONSTS, oparg);
            value = PyStackRef_FromPyObjectBorrow(obj);
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_CONST_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            PyObject *obj = GETITEM(FRAME_CO_CONSTS, oparg);
            value = PyStackRef_FromPyObjectBorrow(obj);
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_SMALL_INT_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            value = PyStackRef_TagInt(oparg);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_SMALL_INT_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            value = PyStackRef_TagInt(oparg);
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_SMALL_INT_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            value = PyStackRef_TagInt(oparg);
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _STORE_FAST_0_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 0;
            assert(oparg == CURRENT_OPARG());
            value = _stack_item_0;
            _PyStackRef tmp = GETLOCAL(oparg);
            GETLOCAL(oparg) = value;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_XCLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_FAST_1_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 1;
            assert(oparg == CURRENT_OPARG());
            value = _stack_item_0;
            _PyStackRef tmp = GETLOCAL(oparg);
            GETLOCAL(oparg) = value;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_XCLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_FAST_2_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 2;
            assert(oparg == CURRENT_OPARG());
            value = _stack_item_0;
            _PyStackRef tmp = GETLOCAL(oparg);
            GETLOCAL(oparg) = value;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_XCLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_FAST_3_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 3;
            assert(oparg == CURRENT_OPARG());
            value = _stack_item_0;
            _PyStackRef tmp = GETLOCAL(oparg);
            GETLOCAL(oparg) = value;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_XCLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_FAST_4_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 4;
            assert(oparg == CURRENT_OPARG());
            value = _stack_item_0;
            _PyStackRef tmp = GETLOCAL(oparg);
            GETLOCAL(oparg) = value;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_XCLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_FAST_5_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 5;
            assert(oparg == CURRENT_OPARG());
            value = _stack_item_0;
            _PyStackRef tmp = GETLOCAL(oparg);
            GETLOCAL(oparg) = value;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_XCLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_FAST_6_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 6;
            assert(oparg == CURRENT_OPARG());
            value = _stack_item_0;
            _PyStackRef tmp = GETLOCAL(oparg);
            GETLOCAL(oparg) = value;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_XCLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_FAST_7_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = 7;
            assert(oparg == CURRENT_OPARG());
            value = _stack_item_0;
            _PyStackRef tmp = GETLOCAL(oparg);
            GETLOCAL(oparg) = value;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_XCLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_FAST_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            value = _stack_item_0;
            _PyStackRef tmp = GETLOCAL(oparg);
            GETLOCAL(oparg) = value;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_XCLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _POP_TOP_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_XCLOSE(value);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _POP_TWO_r20: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef tos;
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            tos = _stack_item_1;
            nos = _stack_item_0;
            stack_pointer[0] = nos;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(tos);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(nos);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _PUSH_NULL_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef res;
            res = PyStackRef_NULL;
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _PUSH_NULL_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            res = PyStackRef_NULL;
            _tos_cache1 = res;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _PUSH_NULL_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            res = PyStackRef_NULL;
            _tos_cache2 = res;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _END_FOR_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(value);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _POP_ITER_r20: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef index_or_null;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            index_or_null = _stack_item_1;
            iter = _stack_item_0;
            (void)index_or_null;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(iter);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _END_SEND_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef receiver;
            _PyStackRef val;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            value = _stack_item_1;
            receiver = _stack_item_0;
            val = value;
            stack_pointer[0] = val;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(receiver);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = val;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _UNARY_NEGATIVE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            _PyStackRef res;
            value = stack_pointer[-1];
            if (PyStackRef_IsTaggedInt(value)) {
                intptr_t i = PyStackRef_UntagInt(value);
                if (i == PYSTACKREF_INT_MIN) {
                    PyObject *res_o = PyLong_FromSsize_t(-i);
                    if (res_o == NULL) {
                        stack_pointer += -1;
                        assert(WITHIN_STACK_BOUNDS());
                        SET_CURRENT_CACHED_VALUES(0);
                        JUMP_TO_ERROR();
                    }
                    res = PyStackRef_FromPyObjectSteal(res_o);
                }
                res = PyStackRef_TagInt(-i);
            }
            else {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyObject *res_o = PyNumber_Negative(PyStackRef_AsPyObjectBorrowNonInt(value));
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(value);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (res_o == NULL) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                res = PyStackRef_FromPyObjectSteal(res_o);
                stack_pointer += 1;
            }
            _tos_cache0 = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _UNARY_NOT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            assert(PyStackRef_BoolCheck(value));
            res = PyStackRef_IsFalse(value)
            ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _UNARY_NOT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            _PyStackRef res;
            value = stack_pointer[-1];
            assert(PyStackRef_BoolCheck(value));
            res = PyStackRef_IsFalse(value)
            ? PyStackRef_True : PyStackRef_False;
            stack_pointer[-1] = res;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _UNARY_NOT_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            value = _stack_item_1;
            assert(PyStackRef_BoolCheck(value));
            res = PyStackRef_IsFalse(value)
            ? PyStackRef_True : PyStackRef_False;
            _tos_cache1 = res;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _UNARY_NOT_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            value = _stack_item_2;
            assert(PyStackRef_BoolCheck(value));
            res = PyStackRef_IsFalse(value)
            ? PyStackRef_True : PyStackRef_False;
            _tos_cache2 = res;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _TO_BOOL_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            _PyStackRef res;
            value = stack_pointer[-1];
            if (PyStackRef_IsTaggedInt(value)) {
                res = PyStackRef_UntagInt(value) ? PyStackRef_True : PyStackRef_False;
            }
            else {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                int err = PyObject_IsTrue(PyStackRef_AsPyObjectBorrowNonInt(value));
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(value);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (err < 0) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                res = err ? PyStackRef_True : PyStackRef_False;
                stack_pointer += 1;
            }
            _tos_cache0 = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _TO_BOOL_BOOL_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            if (!PyStackRef_BoolCheck(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _TO_BOOL_BOOL_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            value = stack_pointer[-1];
            if (!PyStackRef_BoolCheck(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _TO_BOOL_BOOL_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            value = _stack_item_1;
            if (!PyStackRef_BoolCheck(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _TO_BOOL_BOOL_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            value = _stack_item_2;
            if (!PyStackRef_BoolCheck(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _TO_BOOL_INT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            if (!PyStackRef_IsTaggedInt(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            res = PyStackRef_UntagInt(value) ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _TO_BOOL_INT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            _PyStackRef res;
            value = stack_pointer[-1];
            if (!PyStackRef_IsTaggedInt(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            res = PyStackRef_UntagInt(value) ? PyStackRef_True : PyStackRef_False;
            stack_pointer[-1] = res;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _TO_BOOL_INT_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            value = _stack_item_1;
            if (!PyStackRef_IsTaggedInt(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            res = PyStackRef_UntagInt(value) ? PyStackRef_True : PyStackRef_False;
            _tos_cache1 = res;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _TO_BOOL_INT_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            value = _stack_item_2;
            if (!PyStackRef_IsTaggedInt(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            res = PyStackRef_UntagInt(value) ? PyStackRef_True : PyStackRef_False;
            _tos_cache2 = res;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_NOS_LIST_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            nos = _stack_item_0;
            if (!PyStackRef_ListCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = nos;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOS_LIST_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef nos;
            nos = stack_pointer[-2];
            if (!PyStackRef_ListCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOS_LIST_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            nos = stack_pointer[-1];
            if (!PyStackRef_ListCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOS_LIST_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            nos = _stack_item_1;
            if (!PyStackRef_ListCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = nos;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_TOS_LIST_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            tos = _stack_item_0;
            if (!PyStackRef_ListCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = tos;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_TOS_LIST_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef tos;
            tos = stack_pointer[-1];
            if (!PyStackRef_ListCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_TOS_LIST_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            tos = _stack_item_1;
            if (!PyStackRef_ListCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = tos;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_TOS_LIST_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            tos = _stack_item_2;
            if (!PyStackRef_ListCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = tos;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_TOS_SLICE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            tos = _stack_item_0;
            if (!PyStackRef_SliceCheck(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = tos;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_TOS_SLICE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef tos;
            tos = stack_pointer[-1];
            if (!PyStackRef_SliceCheck(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_TOS_SLICE_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            tos = _stack_item_1;
            if (!PyStackRef_SliceCheck(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = tos;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_TOS_SLICE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            tos = _stack_item_2;
            if (!PyStackRef_SliceCheck(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = tos;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _TO_BOOL_LIST_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            assert(PyStackRef_ListCheckExact(value));
            PyObject *value_o = PyStackRef_AsPyObjectBorrowNonInt(value);
            STAT_INC(TO_BOOL, hit);
            res = PyList_GET_SIZE(value_o) ? PyStackRef_True : PyStackRef_False;
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp = value;
            value = res;
            stack_pointer[-1] = value;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _TO_BOOL_NONE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            if (!PyStackRef_IsNone(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            res = PyStackRef_False;
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _TO_BOOL_NONE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            _PyStackRef res;
            value = stack_pointer[-1];
            if (!PyStackRef_IsNone(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            res = PyStackRef_False;
            stack_pointer[-1] = res;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _TO_BOOL_NONE_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            value = _stack_item_1;
            if (!PyStackRef_IsNone(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            res = PyStackRef_False;
            _tos_cache1 = res;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _TO_BOOL_NONE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            value = _stack_item_2;
            if (!PyStackRef_IsNone(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            res = PyStackRef_False;
            _tos_cache2 = res;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_NOS_UNICODE_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            nos = _stack_item_0;
            if (!PyStackRef_UnicodeCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = nos;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOS_UNICODE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef nos;
            nos = stack_pointer[-2];
            if (!PyStackRef_UnicodeCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOS_UNICODE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            nos = stack_pointer[-1];
            if (!PyStackRef_UnicodeCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOS_UNICODE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            nos = _stack_item_1;
            if (!PyStackRef_UnicodeCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = nos;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_TOS_UNICODE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            if (!PyStackRef_UnicodeCheckExact(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_TOS_UNICODE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            value = stack_pointer[-1];
            if (!PyStackRef_UnicodeCheckExact(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_TOS_UNICODE_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            value = _stack_item_1;
            if (!PyStackRef_UnicodeCheckExact(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_TOS_UNICODE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            value = _stack_item_2;
            if (!PyStackRef_UnicodeCheckExact(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _TO_BOOL_STR_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            STAT_INC(TO_BOOL, hit);
            PyObject *value_o = PyStackRef_AsPyObjectBorrowNonInt(value);
            if (value_o == &_Py_STR(empty)) {
                assert(_Py_IsImmortal(value_o));
                res = PyStackRef_False;
            }
            else {
                assert(Py_SIZE(value_o));
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(value);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                res = PyStackRef_True;
            }
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _REPLACE_WITH_TRUE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(value);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            res = PyStackRef_True;
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _UNARY_INVERT_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            _PyStackRef res;
            value = stack_pointer[-1];
            if (PyStackRef_IsTaggedInt(value)) {
                intptr_t i = PyStackRef_UntagInt(value);
                res = PyStackRef_TagInt(~i);
            }
            else {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyObject *res_o = PyNumber_Invert(PyStackRef_AsPyObjectBorrowNonInt(value));
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(value);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (res_o == NULL) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                res = PyStackRef_FromPyObjectSteal(res_o);
                stack_pointer += 1;
            }
            _tos_cache0 = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOS_INT_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef left;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            left = _stack_item_0;
            if (!PyStackRef_IsTaggedInt(left)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = left;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOS_INT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef left;
            left = stack_pointer[-2];
            if (!PyStackRef_IsTaggedInt(left)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOS_INT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef left;
            _PyStackRef _stack_item_0 = _tos_cache0;
            left = stack_pointer[-1];
            if (!PyStackRef_IsTaggedInt(left)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOS_INT_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef left;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            left = _stack_item_1;
            if (!PyStackRef_IsTaggedInt(left)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = left;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_TOS_INT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            if (!PyStackRef_IsTaggedInt(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_TOS_INT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            value = stack_pointer[-1];
            if (!PyStackRef_IsTaggedInt(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_TOS_INT_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            value = _stack_item_1;
            if (!PyStackRef_IsTaggedInt(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_TOS_INT_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            value = _stack_item_2;
            if (!PyStackRef_IsTaggedInt(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _BINARY_OP_MULTIPLY_INT_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            right = _stack_item_1;
            left = _stack_item_0;
            int overflow = _Py_TaggedIntMultiplyOverflow(left, right, &res);
            if (overflow) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_MULTIPLY_INT_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            right = _stack_item_0;
            left = stack_pointer[-1];
            int overflow = _Py_TaggedIntMultiplyOverflow(left, right, &res);
            if (overflow) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            stack_pointer[-1] = res;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _BINARY_OP_MULTIPLY_INT_r32: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            right = _stack_item_2;
            left = _stack_item_1;
            int overflow = _Py_TaggedIntMultiplyOverflow(left, right, &res);
            if (overflow) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = res;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _BINARY_OP_ADD_INT_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            right = _stack_item_1;
            left = _stack_item_0;
            int overflow = _Py_TaggedIntAddOverflow(left, right, &res);
            if (overflow) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_ADD_INT_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            right = _stack_item_0;
            left = stack_pointer[-1];
            int overflow = _Py_TaggedIntAddOverflow(left, right, &res);
            if (overflow) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            stack_pointer[-1] = res;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _BINARY_OP_ADD_INT_r32: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            right = _stack_item_2;
            left = _stack_item_1;
            int overflow = _Py_TaggedIntAddOverflow(left, right, &res);
            if (overflow) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = res;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _BINARY_OP_SUBTRACT_INT_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            right = _stack_item_1;
            left = _stack_item_0;
            int overflow = _Py_TaggedIntSubtractOverflow(left, right, &res);
            if (overflow) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_SUBTRACT_INT_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            right = _stack_item_0;
            left = stack_pointer[-1];
            int overflow = _Py_TaggedIntSubtractOverflow(left, right, &res);
            if (overflow) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            stack_pointer[-1] = res;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _BINARY_OP_SUBTRACT_INT_r32: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            right = _stack_item_2;
            left = _stack_item_1;
            int overflow = _Py_TaggedIntSubtractOverflow(left, right, &res);
            if (overflow) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = res;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOS_FLOAT_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef left;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            left = _stack_item_0;
            if (!PyStackRef_FloatCheckExact(left)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = left;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOS_FLOAT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef left;
            left = stack_pointer[-2];
            if (!PyStackRef_FloatCheckExact(left)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOS_FLOAT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef left;
            _PyStackRef _stack_item_0 = _tos_cache0;
            left = stack_pointer[-1];
            if (!PyStackRef_FloatCheckExact(left)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOS_FLOAT_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef left;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            left = _stack_item_1;
            if (!PyStackRef_FloatCheckExact(left)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = left;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_TOS_FLOAT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            if (!PyStackRef_FloatCheckExact(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_TOS_FLOAT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            value = stack_pointer[-1];
            if (!PyStackRef_FloatCheckExact(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_TOS_FLOAT_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            value = _stack_item_1;
            if (!PyStackRef_FloatCheckExact(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_TOS_FLOAT_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            value = _stack_item_2;
            if (!PyStackRef_FloatCheckExact(value)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _BINARY_OP_MULTIPLY_FLOAT_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            right = _stack_item_1;
            left = _stack_item_0;
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            assert(PyFloat_CheckExact(left_o));
            assert(PyFloat_CheckExact(right_o));
            STAT_INC(BINARY_OP, hit);
            double dres =
            ((PyFloatObject *)left_o)->ob_fval *
            ((PyFloatObject *)right_o)->ob_fval;
            res = _PyFloat_FromDouble_ConsumeInputs(left, right, dres);
            if (PyStackRef_IsNull(res)) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_ADD_FLOAT_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            right = _stack_item_1;
            left = _stack_item_0;
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            assert(PyFloat_CheckExact(left_o));
            assert(PyFloat_CheckExact(right_o));
            STAT_INC(BINARY_OP, hit);
            double dres =
            ((PyFloatObject *)left_o)->ob_fval +
            ((PyFloatObject *)right_o)->ob_fval;
            res = _PyFloat_FromDouble_ConsumeInputs(left, right, dres);
            if (PyStackRef_IsNull(res)) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_SUBTRACT_FLOAT_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            right = _stack_item_1;
            left = _stack_item_0;
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            assert(PyFloat_CheckExact(left_o));
            assert(PyFloat_CheckExact(right_o));
            STAT_INC(BINARY_OP, hit);
            double dres =
            ((PyFloatObject *)left_o)->ob_fval -
            ((PyFloatObject *)right_o)->ob_fval;
            res = _PyFloat_FromDouble_ConsumeInputs(left, right, dres);
            if (PyStackRef_IsNull(res)) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_MULTIPLY_FLOAT__NO_DECREF_INPUTS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            assert(PyFloat_CheckExact(left_o));
            assert(PyFloat_CheckExact(right_o));
            STAT_INC(BINARY_OP, hit);
            double dres =
            ((PyFloatObject *)left_o)->ob_fval *
            ((PyFloatObject *)right_o)->ob_fval;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            res = PyStackRef_FromPyObjectStealNonInt(PyFloat_FromDouble(dres));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (PyStackRef_IsNull(res)) {
                stack_pointer[-2] = res;
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _tos_cache0 = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_ADD_FLOAT__NO_DECREF_INPUTS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            assert(PyFloat_CheckExact(left_o));
            assert(PyFloat_CheckExact(right_o));
            STAT_INC(BINARY_OP, hit);
            double dres =
            ((PyFloatObject *)left_o)->ob_fval +
            ((PyFloatObject *)right_o)->ob_fval;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            res = PyStackRef_FromPyObjectStealNonInt(PyFloat_FromDouble(dres));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (PyStackRef_IsNull(res)) {
                stack_pointer[-2] = res;
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _tos_cache0 = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_SUBTRACT_FLOAT__NO_DECREF_INPUTS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            assert(PyFloat_CheckExact(left_o));
            assert(PyFloat_CheckExact(right_o));
            STAT_INC(BINARY_OP, hit);
            double dres =
            ((PyFloatObject *)left_o)->ob_fval -
            ((PyFloatObject *)right_o)->ob_fval;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            res = PyStackRef_FromPyObjectStealNonInt(PyFloat_FromDouble(dres));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (PyStackRef_IsNull(res)) {
                stack_pointer[-2] = res;
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _tos_cache0 = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_ADD_UNICODE_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            right = _stack_item_1;
            left = _stack_item_0;
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            assert(PyUnicode_CheckExact(left_o));
            assert(PyUnicode_CheckExact(right_o));
            STAT_INC(BINARY_OP, hit);
            PyObject *res_o = PyUnicode_Concat(left_o, right_o);
            PyStackRef_CLOSE_SPECIALIZED(right, _PyUnicode_ExactDealloc);
            PyStackRef_CLOSE_SPECIALIZED(left, _PyUnicode_ExactDealloc);
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_INPLACE_ADD_UNICODE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef right;
            _PyStackRef left;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            assert(PyUnicode_CheckExact(left_o));
            assert(PyUnicode_CheckExact(PyStackRef_AsPyObjectBorrowNonInt(right)));
            int next_oparg;
            #if TIER_ONE
            assert(next_instr->op.code == STORE_FAST);
            next_oparg = next_instr->op.arg;
            #else
            next_oparg = CURRENT_OPERAND0();
            #endif
            _PyStackRef *target_local = &GETLOCAL(next_oparg);
            assert(PyUnicode_CheckExact(left_o));
            if (PyStackRef_AsPyObjectBorrowNonInt(*target_local) != left_o) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(BINARY_OP, hit);
            assert(Py_REFCNT(left_o) >= 2 || !PyStackRef_IsHeapSafe(left));
            PyStackRef_CLOSE_SPECIALIZED(left, _PyUnicode_ExactDealloc);
            PyObject *temp = PyStackRef_AsPyObjectSteal(*target_local);
            PyObject *right_o = PyStackRef_AsPyObjectSteal(right);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyUnicode_Append(&temp, right_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            *target_local = PyStackRef_FromPyObjectSteal(temp);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            Py_DECREF(right_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (PyStackRef_IsNull(*target_local)) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            #if TIER_ONE

            assert(next_instr->op.code == STORE_FAST);
            SKIP_OVER(1);
            #endif
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_BINARY_OP_EXTEND_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef right;
            _PyStackRef left;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            if (PyStackRef_IsTaggedInt(left)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyStackRef_IsTaggedInt(right)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            _PyBinaryOpSpecializationDescr *d = (_PyBinaryOpSpecializationDescr*)descr;
            assert(INLINE_CACHE_ENTRIES_BINARY_OP == 5);
            assert(d && d->guard);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int res = d->guard(left_o, right_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (!res) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _BINARY_OP_EXTEND_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            assert(INLINE_CACHE_ENTRIES_BINARY_OP == 5);
            _PyBinaryOpSpecializationDescr *d = (_PyBinaryOpSpecializationDescr*)descr;
            STAT_INC(BINARY_OP, hit);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = d->action(left_o, right_o);
            _PyStackRef tmp = right;
            right = PyStackRef_NULL;
            stack_pointer[-1] = right;
            PyStackRef_CLOSE(tmp);
            tmp = left;
            left = PyStackRef_NULL;
            stack_pointer[-2] = left;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_SLICE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef stop;
            _PyStackRef start;
            _PyStackRef container;
            _PyStackRef res;
            stop = stack_pointer[-1];
            start = stack_pointer[-2];
            container = stack_pointer[-3];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *slice = _PyBuildSlice_ConsumeRefs(PyStackRef_AsPyObjectSteal(start),
                PyStackRef_AsPyObjectSteal(stop));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            PyObject *res_o;
            if (slice == NULL) {
                res_o = NULL;
            }
            else {
                if (PyStackRef_IsTaggedInt(container)) {
                    stack_pointer += -2;
                    assert(WITHIN_STACK_BOUNDS());
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    _PyErr_SetString(tstate, PyExc_TypeError, "'int' object is not subscriptable");
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                    res_o = NULL;
                }
                else {
                    stack_pointer += -2;
                    assert(WITHIN_STACK_BOUNDS());
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    res_o = PyObject_GetItem(PyStackRef_AsPyObjectBorrowNonInt(container), slice);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                }
                _PyFrame_SetStackPointer(frame, stack_pointer);
                Py_DECREF(slice);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += 2;
            }
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(container);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _STORE_SLICE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef stop;
            _PyStackRef start;
            _PyStackRef container;
            _PyStackRef v;
            stop = stack_pointer[-1];
            start = stack_pointer[-2];
            container = stack_pointer[-3];
            v = stack_pointer[-4];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *slice = _PyBuildSlice_ConsumeRefs(PyStackRef_AsPyObjectSteal(start),
                PyStackRef_AsPyObjectSteal(stop));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            int err;
            if (slice == NULL) {
                err = 1;
            }
            else {
                if (PyStackRef_IsTaggedInt(container)) {
                    stack_pointer += -2;
                    assert(WITHIN_STACK_BOUNDS());
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    _PyErr_SetString(tstate, PyExc_TypeError, "'int' object is not subscriptable");
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                    err = 1;
                }
                else {
                    stack_pointer += -2;
                    assert(WITHIN_STACK_BOUNDS());
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    err = PyObject_SetItem(PyStackRef_AsPyObjectBorrowNonInt(container), slice, PyStackRef_AsPyObjectBorrowed(&v));
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                }
                _PyFrame_SetStackPointer(frame, stack_pointer);
                Py_DECREF(slice);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += 2;
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp = container;
            container = PyStackRef_NULL;
            stack_pointer[-3] = container;
            PyStackRef_CLOSE(tmp);
            tmp = v;
            v = PyStackRef_NULL;
            stack_pointer[-4] = v;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -4;
            assert(WITHIN_STACK_BOUNDS());
            if (err) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _BINARY_OP_SUBSCR_LIST_INT_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef sub_st;
            _PyStackRef list_st;
            _PyStackRef res;
            sub_st = stack_pointer[-1];
            list_st = stack_pointer[-2];
            intptr_t index = PyStackRef_UntagInt(sub_st);
            PyObject *list = PyStackRef_AsPyObjectBorrowNonInt(list_st);
            assert(PyList_CheckExact(list));
            if (index < 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = _PyList_GetItemRef((PyListObject*)list, index);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (res_o == NULL) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(BINARY_OP, hit);
            res = PyStackRef_FromPyObjectSteal(res_o);
            #else
            if (index >= PyList_GET_SIZE(list)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(BINARY_OP, hit);
            PyObject *res_o = PyList_GET_ITEM(list, index);
            assert(res_o != NULL);
            res = PyStackRef_FromPyObjectNew(res_o);
            #endif
            STAT_INC(BINARY_OP, hit);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(list_st);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_SUBSCR_LIST_SLICE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef sub_st;
            _PyStackRef list_st;
            _PyStackRef res;
            sub_st = stack_pointer[-1];
            list_st = stack_pointer[-2];
            PyObject *sub = PyStackRef_AsPyObjectBorrowNonInt(sub_st);
            PyObject *list = PyStackRef_AsPyObjectBorrowNonInt(list_st);
            assert(PySlice_Check(sub));
            assert(PyList_CheckExact(list));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = _PyList_SliceSubscript(list, sub);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            STAT_INC(BINARY_OP, hit);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp = sub_st;
            sub_st = PyStackRef_NULL;
            stack_pointer[-1] = sub_st;
            PyStackRef_CLOSE(tmp);
            tmp = list_st;
            list_st = PyStackRef_NULL;
            stack_pointer[-2] = list_st;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_SUBSCR_STR_INT_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef sub_st;
            _PyStackRef str_st;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            sub_st = _stack_item_1;
            str_st = _stack_item_0;
            intptr_t index = PyStackRef_UntagInt(sub_st);
            PyObject *str = PyStackRef_AsPyObjectBorrowNonInt(str_st);
            assert(PyUnicode_CheckExact(str));
            if (index < 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyUnicode_GET_LENGTH(str) <= index) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            Py_UCS4 c = PyUnicode_READ_CHAR(str, index);
            if (Py_ARRAY_LENGTH(_Py_SINGLETON(strings).ascii) <= c) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(BINARY_OP, hit);
            PyObject *res_o = (PyObject*)&_Py_SINGLETON(strings).ascii[c];
            PyStackRef_CLOSE_SPECIALIZED(sub_st, _PyLong_ExactDealloc);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(str_st);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            res = PyStackRef_FromPyObjectBorrow(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOS_TUPLE_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            nos = _stack_item_0;
            if (!PyStackRef_TupleCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = nos;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOS_TUPLE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef nos;
            nos = stack_pointer[-2];
            if (!PyStackRef_TupleCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOS_TUPLE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            nos = stack_pointer[-1];
            if (!PyStackRef_TupleCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOS_TUPLE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            nos = _stack_item_1;
            if (!PyStackRef_TupleCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = nos;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_TOS_TUPLE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            tos = _stack_item_0;
            if (!PyStackRef_TupleCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = tos;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_TOS_TUPLE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef tos;
            tos = stack_pointer[-1];
            if (!PyStackRef_TupleCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_TOS_TUPLE_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            tos = _stack_item_1;
            if (!PyStackRef_TupleCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = tos;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_TOS_TUPLE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            tos = _stack_item_2;
            if (!PyStackRef_TupleCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = tos;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _BINARY_OP_SUBSCR_TUPLE_INT_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef sub_st;
            _PyStackRef tuple_st;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            sub_st = _stack_item_1;
            tuple_st = _stack_item_0;
            intptr_t index = PyStackRef_UntagInt(sub_st);
            PyObject *tuple = PyStackRef_AsPyObjectBorrowNonInt(tuple_st);
            assert(PyStackRef_IsTaggedInt(sub_st));
            assert(PyTuple_CheckExact(tuple));
            if (index < 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            if (index >= PyTuple_GET_SIZE(tuple)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(BINARY_OP, hit);
            PyObject *res_o = PyTuple_GET_ITEM(tuple, index);
            assert(res_o != NULL);
            PyStackRef_CLOSE_SPECIALIZED(sub_st, _PyLong_ExactDealloc);
            res = PyStackRef_FromPyObjectNew(res_o);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(tuple_st);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOS_DICT_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            nos = _stack_item_0;
            if (!PyStackRef_DictCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = nos;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOS_DICT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef nos;
            nos = stack_pointer[-2];
            if (!PyStackRef_DictCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOS_DICT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            nos = stack_pointer[-1];
            if (!PyStackRef_DictCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOS_DICT_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            nos = _stack_item_1;
            if (!PyStackRef_DictCheckExact(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = nos;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_TOS_DICT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            tos = _stack_item_0;
            if (!PyStackRef_DictCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = tos;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_TOS_DICT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef tos;
            tos = stack_pointer[-1];
            if (!PyStackRef_DictCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_TOS_DICT_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            tos = _stack_item_1;
            if (!PyStackRef_DictCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = tos;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_TOS_DICT_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            tos = _stack_item_2;
            if (!PyStackRef_DictCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = tos;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _BINARY_OP_SUBSCR_DICT_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef sub_st;
            _PyStackRef dict_st;
            _PyStackRef res;
            sub_st = stack_pointer[-1];
            dict_st = stack_pointer[-2];
            PyObject *sub = PyStackRef_AsPyObjectBorrowed(&sub_st);
            PyObject *dict = PyStackRef_AsPyObjectBorrowNonInt(dict_st);
            assert(PyDict_CheckExact(dict));
            STAT_INC(BINARY_OP, hit);
            PyObject *res_o;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int rc = PyDict_GetItemRef(dict, sub, &res_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (rc == 0) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyErr_SetKeyError(sub);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp = sub_st;
            sub_st = PyStackRef_NULL;
            stack_pointer[-1] = sub_st;
            PyStackRef_CLOSE(tmp);
            tmp = dict_st;
            dict_st = PyStackRef_NULL;
            stack_pointer[-2] = dict_st;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (rc <= 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_SUBSCR_CHECK_FUNC_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef container;
            _PyStackRef getitem;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            container = _stack_item_0;
            PyTypeObject *tp = PyStackRef_TYPE(container);
            if (!PyType_HasFeature(tp, Py_TPFLAGS_HEAPTYPE)) {
                stack_pointer[0] = container;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyHeapTypeObject *ht = (PyHeapTypeObject *)tp;
            PyObject *getitem_o = FT_ATOMIC_LOAD_PTR_ACQUIRE(ht->_spec_cache.getitem);
            if (getitem_o == NULL) {
                stack_pointer[0] = container;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(PyFunction_Check(getitem_o));
            uint32_t cached_version = FT_ATOMIC_LOAD_UINT32_RELAXED(ht->_spec_cache.getitem_version);
            if (((PyFunctionObject *)getitem_o)->func_version != cached_version) {
                stack_pointer[0] = container;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyCodeObject *code = (PyCodeObject *)PyFunction_GET_CODE(getitem_o);
            assert(code->co_argcount == 2);
            if (!_PyThreadState_HasStackSpace(tstate, code->co_framesize)) {
                stack_pointer[0] = container;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            getitem = PyStackRef_FromPyObjectNew(getitem_o);
            STAT_INC(BINARY_OP, hit);
            _tos_cache2 = getitem;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = container;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _BINARY_OP_SUBSCR_INIT_CALL_r31: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef getitem;
            _PyStackRef sub;
            _PyStackRef container;
            _PyStackRef new_frame;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            getitem = _stack_item_2;
            sub = _stack_item_1;
            container = _stack_item_0;
            _PyInterpreterFrame* pushed_frame = _PyFrame_PushUnchecked(tstate, getitem, 2, frame);
            pushed_frame->localsplus[0] = container;
            pushed_frame->localsplus[1] = sub;
            frame->return_offset = 6 ;
            new_frame = PyStackRef_Wrap(pushed_frame);
            _tos_cache0 = new_frame;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LIST_APPEND_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef v;
            _PyStackRef list;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            v = _stack_item_0;
            list = stack_pointer[-1 - (oparg-1)];
            int err = _PyList_AppendTakeRef((PyListObject *)PyStackRef_AsPyObjectBorrowNonInt(list),
                PyStackRef_AsPyObjectSteal(v));
            if (err < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _SET_ADD_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef v;
            _PyStackRef set;
            oparg = CURRENT_OPARG();
            v = stack_pointer[-1];
            set = stack_pointer[-2 - (oparg-1)];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = _PySet_AddTakeRef((PySetObject *)PyStackRef_AsPyObjectBorrowNonInt(set),
                                        PyStackRef_AsPyObjectSteal(v));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err) {
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_SUBSCR_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef sub;
            _PyStackRef container;
            _PyStackRef v;
            sub = stack_pointer[-1];
            container = stack_pointer[-2];
            v = stack_pointer[-3];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = PyObject_SetItem(PyStackRef_AsPyObjectBorrowed(&container), PyStackRef_AsPyObjectBorrowed(&sub), PyStackRef_AsPyObjectBorrowed(&v));
            _PyStackRef tmp = sub;
            sub = PyStackRef_NULL;
            stack_pointer[-1] = sub;
            PyStackRef_CLOSE(tmp);
            tmp = container;
            container = PyStackRef_NULL;
            stack_pointer[-2] = container;
            PyStackRef_CLOSE(tmp);
            tmp = v;
            v = PyStackRef_NULL;
            stack_pointer[-3] = v;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            if (err) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_SUBSCR_LIST_INT_r30: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef sub_st;
            _PyStackRef list_st;
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            sub_st = _stack_item_2;
            list_st = _stack_item_1;
            value = _stack_item_0;
            intptr_t index = PyStackRef_UntagInt(sub_st);
            PyObject *list = PyStackRef_AsPyObjectBorrowNonInt(list_st);
            assert(PyStackRef_IsTaggedInt(sub_st));
            assert(PyList_CheckExact(list));
            if (index < 0) {
                stack_pointer[0] = value;
                stack_pointer[1] = list_st;
                stack_pointer[2] = sub_st;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (!LOCK_OBJECT(list)) {
                stack_pointer[0] = value;
                stack_pointer[1] = list_st;
                stack_pointer[2] = sub_st;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (index >= PyList_GET_SIZE(list)) {
                UNLOCK_OBJECT(list);
                if (true) {
                    stack_pointer[0] = value;
                    stack_pointer[1] = list_st;
                    stack_pointer[2] = sub_st;
                    stack_pointer += 3;
                    assert(WITHIN_STACK_BOUNDS());
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            STAT_INC(STORE_SUBSCR, hit);
            PyObject *old_value = PyList_GET_ITEM(list, index);
            FT_ATOMIC_STORE_PTR_RELEASE(_PyList_ITEMS(list)[index],
                                        PyStackRef_AsPyObjectSteal(value));
            assert(old_value != NULL);
            UNLOCK_OBJECT(list);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(list_st);
            Py_DECREF(old_value);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_SUBSCR_DICT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef sub;
            _PyStackRef dict_st;
            _PyStackRef value;
            sub = stack_pointer[-1];
            dict_st = stack_pointer[-2];
            value = stack_pointer[-3];
            PyObject *dict = PyStackRef_AsPyObjectBorrowNonInt(dict_st);
            assert(PyDict_CheckExact(dict));
            STAT_INC(STORE_SUBSCR, hit);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = _PyDict_SetItem_Take2((PyDictObject *)dict,
                PyStackRef_AsPyObjectSteal(sub),
                PyStackRef_AsPyObjectSteal(value));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(dict_st);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _DELETE_SUBSCR_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef sub;
            _PyStackRef container;
            sub = stack_pointer[-1];
            container = stack_pointer[-2];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = PyObject_DelItem(PyStackRef_AsPyObjectBorrowed(&container),
                                       PyStackRef_AsPyObjectBorrowed(&sub));
            _PyStackRef tmp = sub;
            sub = PyStackRef_NULL;
            stack_pointer[-1] = sub;
            PyStackRef_CLOSE(tmp);
            tmp = container;
            container = PyStackRef_NULL;
            stack_pointer[-2] = container;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (err) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CALL_INTRINSIC_1_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            value = stack_pointer[-1];
            assert(oparg <= MAX_INTRINSIC_1);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = _PyIntrinsics_UnaryFunctions[oparg].func(tstate, PyStackRef_AsPyObjectBorrowed(&value));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(value);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CALL_INTRINSIC_2_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value1_st;
            _PyStackRef value2_st;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            value1_st = stack_pointer[-1];
            value2_st = stack_pointer[-2];
            assert(oparg <= MAX_INTRINSIC_2);
            PyObject *value1 = PyStackRef_AsPyObjectBorrowed(&value1_st);
            PyObject *value2 = PyStackRef_AsPyObjectBorrowed(&value2_st);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = _PyIntrinsics_BinaryFunctions[oparg].func(tstate, value2, value1);
            _PyStackRef tmp = value1_st;
            value1_st = PyStackRef_NULL;
            stack_pointer[-1] = value1_st;
            PyStackRef_CLOSE(tmp);
            tmp = value2_st;
            value2_st = PyStackRef_NULL;
            stack_pointer[-2] = value2_st;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _RETURN_VALUE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef retval;
            _PyStackRef res;
            retval = stack_pointer[-1];
            assert(frame->owner != FRAME_OWNED_BY_INTERPRETER);
            _PyStackRef temp = PyStackRef_MakeHeapSafe(retval);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            assert(STACK_LEVEL() == 0);
            _Py_LeaveRecursiveCallPy(tstate);
            _PyInterpreterFrame *dying = frame;
            frame = tstate->current_frame = dying->previous;
            _PyEval_FrameClearAndPop(tstate, dying);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            LOAD_IP(frame->return_offset);
            res = temp;
            LLTRACE_RESUME_FRAME();
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GET_AITER_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef obj;
            _PyStackRef iter;
            obj = stack_pointer[-1];
            unaryfunc getter = NULL;
            PyTypeObject *type = PyStackRef_TYPE(obj);
            if (type->tp_as_async != NULL) {
                getter = type->tp_as_async->am_aiter;
            }
            if (getter == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyErr_Format(tstate, PyExc_TypeError,
                              "'async for' requires an object with "
                              "__aiter__ method, got %.100s",
                              type->tp_name);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(obj);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            PyObject *obj_o = PyStackRef_AsPyObjectBorrowNonInt(obj);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *iter_o = (*getter)(obj_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(obj);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (iter_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            if (Py_TYPE(iter_o)->tp_as_async == NULL ||
                Py_TYPE(iter_o)->tp_as_async->am_anext == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyErr_Format(tstate, PyExc_TypeError,
                              "'async for' received an object from __aiter__ "
                              "that does not implement __anext__: %.100s",
                              Py_TYPE(iter_o)->tp_name);
                Py_DECREF(iter_o);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            iter = PyStackRef_FromPyObjectStealNonInt(iter_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = iter;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GET_ANEXT_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef aiter;
            _PyStackRef awaitable;
            aiter = stack_pointer[-1];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *awaitable_o = _PyEval_GetANext(PyStackRef_AsPyObjectBorrowed(&aiter));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (awaitable_o == NULL) {
                stack_pointer[-1] = aiter;
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            awaitable = PyStackRef_FromPyObjectSteal(awaitable_o);
            _tos_cache0 = awaitable;
            stack_pointer[-1] = aiter;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GET_AWAITABLE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef iterable;
            _PyStackRef iter;
            oparg = CURRENT_OPARG();
            iterable = stack_pointer[-1];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *iter_o = _PyEval_GetAwaitable(PyStackRef_AsPyObjectBorrowed(&iterable), oparg);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(iterable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (iter_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            iter = PyStackRef_FromPyObjectStealNonInt(iter_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = iter;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        /* _SEND is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _SEND_GEN_FRAME_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef v;
            _PyStackRef receiver;
            _PyStackRef gen_frame;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            v = _stack_item_1;
            receiver = _stack_item_0;
            PyGenObject *gen = (PyGenObject *)PyStackRef_AsPyObjectBorrowNonInt(receiver);
            if (Py_TYPE(gen) != &PyGen_Type && Py_TYPE(gen) != &PyCoro_Type) {
                stack_pointer[0] = receiver;
                stack_pointer[1] = v;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (gen->gi_frame_state >= FRAME_EXECUTING) {
                stack_pointer[0] = receiver;
                stack_pointer[1] = v;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(SEND, hit);
            _PyInterpreterFrame *pushed_frame = &gen->gi_iframe;
            _PyFrame_StackPush(pushed_frame, PyStackRef_MakeHeapSafe(v));
            gen->gi_frame_state = FRAME_EXECUTING;
            gen->gi_exc_state.previous_item = tstate->exc_info;
            tstate->exc_info = &gen->gi_exc_state;
            assert( 2 + oparg <= UINT16_MAX);
            frame->return_offset = (uint16_t)( 2 + oparg);
            pushed_frame->previous = frame;
            gen_frame = PyStackRef_Wrap(pushed_frame);
            _tos_cache1 = gen_frame;
            _tos_cache0 = receiver;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _YIELD_VALUE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef retval;
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            retval = _stack_item_0;
            assert(frame->owner != FRAME_OWNED_BY_INTERPRETER);
            frame->instr_ptr++;
            PyGenObject *gen = _PyGen_GetGeneratorFromFrame(frame);
            assert(FRAME_SUSPENDED_YIELD_FROM == FRAME_SUSPENDED + 1);
            assert(oparg == 0 || oparg == 1);
            gen->gi_frame_state = FRAME_SUSPENDED + oparg;
            _PyStackRef temp = retval;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            tstate->exc_info = gen->gi_exc_state.previous_item;
            gen->gi_exc_state.previous_item = NULL;
            _Py_LeaveRecursiveCallPy(tstate);
            _PyInterpreterFrame *gen_frame = frame;
            frame = tstate->current_frame = frame->previous;
            gen_frame->previous = NULL;
            assert(INLINE_CACHE_ENTRIES_SEND == INLINE_CACHE_ENTRIES_FOR_ITER);
            #if TIER_ONE
            assert(frame->instr_ptr->op.code == INSTRUMENTED_LINE ||
                  frame->instr_ptr->op.code == INSTRUMENTED_INSTRUCTION ||
                  _PyOpcode_Deopt[frame->instr_ptr->op.code] == SEND ||
                  _PyOpcode_Deopt[frame->instr_ptr->op.code] == FOR_ITER ||
                  _PyOpcode_Deopt[frame->instr_ptr->op.code] == INTERPRETER_EXIT ||
                  _PyOpcode_Deopt[frame->instr_ptr->op.code] == ENTER_EXECUTOR);
            #endif
            stack_pointer = _PyFrame_GetStackPointer(frame);
            LOAD_IP(1 + INLINE_CACHE_ENTRIES_SEND);
            value = PyStackRef_MakeHeapSafe(temp);
            LLTRACE_RESUME_FRAME();
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _POP_EXCEPT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef exc_value;
            exc_value = stack_pointer[-1];
            _PyErr_StackItem *exc_info = tstate->exc_info;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            Py_XSETREF(exc_info->exc_value,
                       PyStackRef_IsNone(exc_value)
                       ? NULL : PyStackRef_AsPyObjectSteal(exc_value));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _LOAD_COMMON_CONSTANT_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            assert(oparg < NUM_COMMON_CONSTANTS);
            value = PyStackRef_FromPyObjectNew(tstate->interp->common_consts[oparg]);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_COMMON_CONSTANT_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            assert(oparg < NUM_COMMON_CONSTANTS);
            value = PyStackRef_FromPyObjectNew(tstate->interp->common_consts[oparg]);
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_COMMON_CONSTANT_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            assert(oparg < NUM_COMMON_CONSTANTS);
            value = PyStackRef_FromPyObjectNew(tstate->interp->common_consts[oparg]);
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_BUILD_CLASS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef bc;
            PyObject *bc_o;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = PyMapping_GetOptionalItem(BUILTINS(), &_Py_ID(__build_class__), &bc_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            if (bc_o == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyErr_SetString(tstate, PyExc_NameError,
                                 "__build_class__ not found");
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            bc = PyStackRef_FromPyObjectSteal(bc_o);
            _tos_cache0 = bc;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _STORE_NAME_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef v;
            oparg = CURRENT_OPARG();
            v = stack_pointer[-1];
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            PyObject *ns = LOCALS();
            int err;
            if (ns == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyErr_Format(tstate, PyExc_SystemError,
                              "no locals found when storing %R", name);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(v);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            if (PyDict_CheckExact(ns)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                err = PyDict_SetItem(ns, name, PyStackRef_AsPyObjectBorrowed(&v));
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            else {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                err = PyObject_SetItem(ns, name, PyStackRef_AsPyObjectBorrowed(&v));
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(v);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _DELETE_NAME_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            oparg = CURRENT_OPARG();
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            PyObject *ns = LOCALS();
            int err;
            if (ns == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyErr_Format(tstate, PyExc_SystemError,
                              "no locals when deleting %R", name);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            err = PyObject_DelItem(ns, name);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err != 0) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyEval_FormatExcCheckArg(tstate, PyExc_NameError,
                    NAME_ERROR_MSG,
                    name);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _UNPACK_SEQUENCE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef seq;
            _PyStackRef *top;
            oparg = CURRENT_OPARG();
            seq = stack_pointer[-1];
            top = &stack_pointer[-1 + oparg];
            PyObject *seq_o = PyStackRef_AsPyObjectSteal(seq);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int res = _PyEval_UnpackIterableStackRef(tstate, seq_o, oparg, -1, top);
            Py_DECREF(seq_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (res == 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            stack_pointer += oparg;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _UNPACK_SEQUENCE_TWO_TUPLE_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef seq;
            _PyStackRef val1;
            _PyStackRef val0;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            seq = _stack_item_0;
            assert(oparg == 2);
            PyObject *seq_o = PyStackRef_AsPyObjectBorrowNonInt(seq);
            assert(PyTuple_CheckExact(seq_o));
            if (PyTuple_GET_SIZE(seq_o) != 2) {
                stack_pointer[0] = seq;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(UNPACK_SEQUENCE, hit);
            val0 = PyStackRef_FromPyObjectNew(PyTuple_GET_ITEM(seq_o, 0));
            val1 = PyStackRef_FromPyObjectNew(PyTuple_GET_ITEM(seq_o, 1));
            stack_pointer[0] = val1;
            stack_pointer[1] = val0;
            stack_pointer += 2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(seq);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache1 = val0;
            _tos_cache0 = val1;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _UNPACK_SEQUENCE_TUPLE_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef seq;
            _PyStackRef *values;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            seq = _stack_item_0;
            values = &stack_pointer[0];
            PyObject *seq_o = PyStackRef_AsPyObjectBorrowNonInt(seq);
            assert(PyTuple_CheckExact(seq_o));
            if (PyTuple_GET_SIZE(seq_o) != oparg) {
                stack_pointer[0] = seq;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(UNPACK_SEQUENCE, hit);
            PyObject **items = _PyTuple_ITEMS(seq_o);
            for (int i = oparg; --i >= 0; ) {
                *values++ = PyStackRef_FromPyObjectNew(items[i]);
            }
            stack_pointer += oparg;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(seq);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _UNPACK_SEQUENCE_LIST_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef seq;
            _PyStackRef *values;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            seq = _stack_item_0;
            values = &stack_pointer[0];
            PyObject *seq_o = PyStackRef_AsPyObjectBorrowNonInt(seq);
            assert(PyList_CheckExact(seq_o));
            if (!LOCK_OBJECT(seq_o)) {
                stack_pointer[0] = seq;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyList_GET_SIZE(seq_o) != oparg) {
                UNLOCK_OBJECT(seq_o);
                if (true) {
                    stack_pointer[0] = seq;
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            STAT_INC(UNPACK_SEQUENCE, hit);
            PyObject **items = _PyList_ITEMS(seq_o);
            for (int i = oparg; --i >= 0; ) {
                *values++ = PyStackRef_FromPyObjectNew(items[i]);
            }
            UNLOCK_OBJECT(seq_o);
            stack_pointer += oparg;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(seq);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _UNPACK_EX_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef seq;
            _PyStackRef *top;
            oparg = CURRENT_OPARG();
            seq = stack_pointer[-1];
            top = &stack_pointer[(oparg & 0xFF) + (oparg >> 8)];
            PyObject *seq_o = PyStackRef_AsPyObjectSteal(seq);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int res = _PyEval_UnpackIterableStackRef(tstate, seq_o, oparg & 0xFF, oparg >> 8, top);
            Py_DECREF(seq_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (res == 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            stack_pointer += 1 + (oparg & 0xFF) + (oparg >> 8);
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_ATTR_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            _PyStackRef v;
            oparg = CURRENT_OPARG();
            owner = stack_pointer[-1];
            v = stack_pointer[-2];
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = PyObject_SetAttr(PyStackRef_AsPyObjectBorrowed(&owner),
                                       name, PyStackRef_AsPyObjectBorrowed(&v));
            _PyStackRef tmp = owner;
            owner = PyStackRef_NULL;
            stack_pointer[-1] = owner;
            PyStackRef_CLOSE(tmp);
            tmp = v;
            v = PyStackRef_NULL;
            stack_pointer[-2] = v;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (err) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _DELETE_ATTR_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            oparg = CURRENT_OPARG();
            owner = stack_pointer[-1];
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = PyObject_DelAttr(PyStackRef_AsPyObjectBorrowed(&owner), name);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(owner);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_GLOBAL_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef v;
            oparg = CURRENT_OPARG();
            v = stack_pointer[-1];
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = PyDict_SetItem(GLOBALS(), name, PyStackRef_AsPyObjectBorrowed(&v));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(v);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _DELETE_GLOBAL_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            oparg = CURRENT_OPARG();
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = PyDict_Pop(GLOBALS(), name, NULL);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            if (err == 0) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyEval_FormatExcCheckArg(tstate, PyExc_NameError,
                    NAME_ERROR_MSG, name);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _LOAD_LOCALS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef locals;
            PyObject *l = LOCALS();
            if (l == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyErr_SetString(tstate, PyExc_SystemError,
                                 "no locals found");
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            locals = PyStackRef_FromPyObjectNew(l);
            _tos_cache0 = locals;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        /* _LOAD_FROM_DICT_OR_GLOBALS is not a viable micro-op for tier 2 because it has both popping and not-popping errors */

        case _LOAD_NAME_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef v;
            oparg = CURRENT_OPARG();
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *v_o = _PyEval_LoadName(tstate, frame, name);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (v_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            v = PyStackRef_FromPyObjectSteal(v_o);
            _tos_cache0 = v;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_GLOBAL_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *res;
            oparg = CURRENT_OPARG();
            res = &stack_pointer[0];
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyEval_LoadGlobalStackRef(GLOBALS(), BUILTINS(), name, res);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (PyStackRef_IsNull(*res)) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _PUSH_NULL_CONDITIONAL_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *null;
            oparg = CURRENT_OPARG();
            null = &stack_pointer[0];
            if (oparg & 1) {
                null[0] = PyStackRef_NULL;
            }
            stack_pointer += (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_GLOBALS_VERSION_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            uint16_t version = (uint16_t)CURRENT_OPERAND0();
            PyDictObject *dict = (PyDictObject *)GLOBALS();
            if (!PyDict_CheckExact(dict)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyDictKeysObject *keys = FT_ATOMIC_LOAD_PTR_ACQUIRE(dict->ma_keys);
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(keys->dk_version) != version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(DK_IS_UNICODE(keys));
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_GLOBALS_VERSION_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            uint16_t version = (uint16_t)CURRENT_OPERAND0();
            PyDictObject *dict = (PyDictObject *)GLOBALS();
            if (!PyDict_CheckExact(dict)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyDictKeysObject *keys = FT_ATOMIC_LOAD_PTR_ACQUIRE(dict->ma_keys);
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(keys->dk_version) != version) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(DK_IS_UNICODE(keys));
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_GLOBALS_VERSION_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            uint16_t version = (uint16_t)CURRENT_OPERAND0();
            PyDictObject *dict = (PyDictObject *)GLOBALS();
            if (!PyDict_CheckExact(dict)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyDictKeysObject *keys = FT_ATOMIC_LOAD_PTR_ACQUIRE(dict->ma_keys);
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(keys->dk_version) != version) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(DK_IS_UNICODE(keys));
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_GLOBALS_VERSION_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            uint16_t version = (uint16_t)CURRENT_OPERAND0();
            PyDictObject *dict = (PyDictObject *)GLOBALS();
            if (!PyDict_CheckExact(dict)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyDictKeysObject *keys = FT_ATOMIC_LOAD_PTR_ACQUIRE(dict->ma_keys);
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(keys->dk_version) != version) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(DK_IS_UNICODE(keys));
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_GLOBAL_MODULE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef res;
            uint16_t version = (uint16_t)CURRENT_OPERAND0();
            uint16_t index = (uint16_t)CURRENT_OPERAND1();
            PyDictObject *dict = (PyDictObject *)GLOBALS();
            if (!PyDict_CheckExact(dict)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyDictKeysObject *keys = FT_ATOMIC_LOAD_PTR_ACQUIRE(dict->ma_keys);
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(keys->dk_version) != version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(DK_IS_UNICODE(keys));
            PyDictUnicodeEntry *entries = DK_UNICODE_ENTRIES(keys);
            assert(index < DK_SIZE(keys));
            PyObject *res_o = FT_ATOMIC_LOAD_PTR_RELAXED(entries[index].me_value);
            if (res_o == NULL) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #if Py_GIL_DISABLED
            int increfed = _Py_TryIncrefCompareStackRef(&entries[index].me_value, res_o, &res);
            if (!increfed) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #else
            res = PyStackRef_FromPyObjectNew(res_o);
            #endif
            STAT_INC(LOAD_GLOBAL, hit);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_GLOBAL_BUILTINS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef res;
            uint16_t version = (uint16_t)CURRENT_OPERAND0();
            uint16_t index = (uint16_t)CURRENT_OPERAND1();
            PyDictObject *dict = (PyDictObject *)BUILTINS();
            if (!PyDict_CheckExact(dict)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyDictKeysObject *keys = FT_ATOMIC_LOAD_PTR_ACQUIRE(dict->ma_keys);
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(keys->dk_version) != version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(DK_IS_UNICODE(keys));
            PyDictUnicodeEntry *entries = DK_UNICODE_ENTRIES(keys);
            PyObject *res_o = FT_ATOMIC_LOAD_PTR_RELAXED(entries[index].me_value);
            if (res_o == NULL) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #if Py_GIL_DISABLED
            int increfed = _Py_TryIncrefCompareStackRef(&entries[index].me_value, res_o, &res);
            if (!increfed) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #else
            res = PyStackRef_FromPyObjectNew(res_o);
            #endif
            STAT_INC(LOAD_GLOBAL, hit);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _DELETE_FAST_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            oparg = CURRENT_OPARG();
            _PyStackRef v = GETLOCAL(oparg);
            if (PyStackRef_IsNull(v)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyEval_FormatExcCheckArg(tstate, PyExc_UnboundLocalError,
                    UNBOUNDLOCAL_ERROR_MSG,
                    PyTuple_GetItem(_PyFrame_GetCode(frame)->co_localsplusnames, oparg)
                );
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyStackRef tmp = GETLOCAL(oparg);
            GETLOCAL(oparg) = PyStackRef_NULL;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_XCLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _MAKE_CELL_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            oparg = CURRENT_OPARG();
            PyObject *initial = PyStackRef_AsPyObjectBorrowed(&GETLOCAL(oparg));
            PyObject *cell = PyCell_New(initial);
            if (cell == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyStackRef tmp = GETLOCAL(oparg);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            GETLOCAL(oparg) = PyStackRef_FromPyObjectStealNonInt(cell);
            PyStackRef_XCLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _DELETE_DEREF_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            oparg = CURRENT_OPARG();
            PyObject *cell = PyStackRef_AsPyObjectBorrowed(&GETLOCAL(oparg));
            PyObject *oldobj = PyCell_SwapTakeRef((PyCellObject *)cell, NULL);
            if (oldobj == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyEval_FormatExcUnbound(tstate, _PyFrame_GetCode(frame), oparg);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            Py_DECREF(oldobj);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _LOAD_FROM_DICT_OR_DEREF_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef class_dict_st;
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            class_dict_st = stack_pointer[-1];
            PyObject *value_o;
            PyObject *name;
            PyObject *class_dict = PyStackRef_AsPyObjectBorrowed(&class_dict_st);
            assert(class_dict);
            assert(oparg >= 0 && oparg < _PyFrame_GetCode(frame)->co_nlocalsplus);
            name = PyTuple_GET_ITEM(_PyFrame_GetCode(frame)->co_localsplusnames, oparg);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = PyMapping_GetOptionalItem(class_dict, name, &value_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            if (!value_o) {
                PyCellObject *cell = (PyCellObject *)PyStackRef_AsPyObjectBorrowed(&GETLOCAL(oparg));
                value_o = PyCell_GetRef(cell);
                if (value_o == NULL) {
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    _PyEval_FormatExcUnbound(tstate, _PyFrame_GetCode(frame), oparg);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(class_dict_st);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            value = PyStackRef_FromPyObjectSteal(value_o);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_DEREF_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            PyCellObject *cell = (PyCellObject *)PyStackRef_AsPyObjectBorrowNonInt(GETLOCAL(oparg));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            value = _PyCell_GetStackRef(cell);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (PyStackRef_IsNull(value)) {
                stack_pointer[0] = value;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyEval_FormatExcUnbound(tstate, _PyFrame_GetCode(frame), oparg);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _STORE_DEREF_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef v;
            oparg = CURRENT_OPARG();
            v = stack_pointer[-1];
            PyCellObject *cell = (PyCellObject *)PyStackRef_AsPyObjectBorrowNonInt(GETLOCAL(oparg));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyCell_SetTakeRef(cell, PyStackRef_AsPyObjectSteal(v));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _COPY_FREE_VARS_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            oparg = CURRENT_OPARG();
            PyCodeObject *co = _PyFrame_GetCode(frame);
            assert(PyStackRef_FunctionCheck(frame->f_funcobj));
            PyFunctionObject *func = (PyFunctionObject *)PyStackRef_AsPyObjectBorrowNonInt(frame->f_funcobj);
            PyObject *closure = func->func_closure;
            assert(oparg == co->co_nfreevars);
            int offset = co->co_nlocalsplus - oparg;
            for (int i = 0; i < oparg; ++i) {
                PyObject *o = PyTuple_GET_ITEM(closure, i);
                frame->localsplus[offset + i] = PyStackRef_FromPyObjectNew(o);
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _BUILD_STRING_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *pieces;
            _PyStackRef str;
            oparg = CURRENT_OPARG();
            pieces = &stack_pointer[-oparg];
            STACKREFS_TO_PYOBJECTS(pieces, oparg, pieces_o);
            if (CONVERSION_FAILED(pieces_o)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp;
                for (int _i = oparg; --_i >= 0;) {
                    tmp = pieces[_i];
                    pieces[_i] = PyStackRef_NULL;
                    PyStackRef_CLOSE(tmp);
                }
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -oparg;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            PyObject *str_o = _PyUnicode_JoinArray(&_Py_STR(empty), pieces_o, oparg);
            STACKREFS_TO_PYOBJECTS_CLEANUP(pieces_o);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp;
            for (int _i = oparg; --_i >= 0;) {
                tmp = pieces[_i];
                pieces[_i] = PyStackRef_NULL;
                PyStackRef_CLOSE(tmp);
            }
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (str_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            str = PyStackRef_FromPyObjectSteal(str_o);
            _tos_cache0 = str;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BUILD_INTERPOLATION_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *format;
            _PyStackRef str;
            _PyStackRef value;
            _PyStackRef interpolation;
            oparg = CURRENT_OPARG();
            format = &stack_pointer[-(oparg & 1)];
            str = stack_pointer[-1 - (oparg & 1)];
            value = stack_pointer[-2 - (oparg & 1)];
            PyObject *value_o = PyStackRef_AsPyObjectBorrowed(&value);
            PyObject *str_o = PyStackRef_AsPyObjectBorrowNonInt(str);
            int conversion = oparg >> 2;
            PyObject *format_o;
            if (oparg & 1) {
                format_o = PyStackRef_AsPyObjectBorrowNonInt(format[0]);
            }
            else {
                format_o = &_Py_STR(empty);
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *interpolation_o = _PyInterpolation_Build(value_o, str_o, conversion, format_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (oparg & 1) {
                stack_pointer += -(oparg & 1);
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(format[0]);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            else {
                stack_pointer += -(oparg & 1);
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(str);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(value);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (interpolation_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            interpolation = PyStackRef_FromPyObjectSteal(interpolation_o);
            _tos_cache0 = interpolation;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BUILD_TEMPLATE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef interpolations;
            _PyStackRef strings;
            _PyStackRef template;
            interpolations = stack_pointer[-1];
            strings = stack_pointer[-2];
            PyObject *strings_o = PyStackRef_AsPyObjectBorrowNonInt(strings);
            PyObject *interpolations_o = PyStackRef_AsPyObjectBorrowNonInt(interpolations);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *template_o = _PyTemplate_Build(strings_o, interpolations_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(interpolations);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(strings);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (template_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            template = PyStackRef_FromPyObjectSteal(template_o);
            _tos_cache0 = template;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BUILD_TUPLE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *values;
            _PyStackRef tup;
            oparg = CURRENT_OPARG();
            values = &stack_pointer[-oparg];
            PyObject *tup_o = _PyTuple_FromStackRefStealOnSuccess(values, oparg);
            if (tup_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            tup = PyStackRef_FromPyObjectStealMortal(tup_o);
            _tos_cache0 = tup;
            stack_pointer += -oparg;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BUILD_LIST_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *values;
            _PyStackRef list;
            oparg = CURRENT_OPARG();
            values = &stack_pointer[-oparg];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *list_o = _PyList_FromStackRefStealOnSuccess(values, oparg);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (list_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            list = PyStackRef_FromPyObjectStealMortal(list_o);
            _tos_cache0 = list;
            stack_pointer += -oparg;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LIST_EXTEND_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef iterable_st;
            _PyStackRef list_st;
            oparg = CURRENT_OPARG();
            iterable_st = stack_pointer[-1];
            list_st = stack_pointer[-2 - (oparg-1)];
            PyObject *list = PyStackRef_AsPyObjectBorrowNonInt(list_st);
            PyObject *iterable = PyStackRef_AsPyObjectBorrowed(&iterable_st);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *none_val = _PyList_Extend((PyListObject *)list, iterable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (none_val == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                int matches = _PyErr_ExceptionMatches(tstate, PyExc_TypeError);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (matches &&
                    (Py_TYPE(iterable)->tp_iter == NULL && !PySequence_Check(iterable)))
                {
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    _PyErr_Clear(tstate);
                    _PyErr_Format(tstate, PyExc_TypeError,
                                  "Value after * must be an iterable, not %.200s",
                                  Py_TYPE(iterable)->tp_name);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                }
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(iterable_st);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            assert(Py_IsNone(none_val));
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(iterable_st);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _SET_UPDATE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef iterable;
            _PyStackRef set;
            oparg = CURRENT_OPARG();
            iterable = stack_pointer[-1];
            set = stack_pointer[-2 - (oparg-1)];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = _PySet_Update(PyStackRef_AsPyObjectBorrowNonInt(set),
                                    PyStackRef_AsPyObjectBorrowed(&iterable));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(iterable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _BUILD_SET_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *values;
            _PyStackRef set;
            oparg = CURRENT_OPARG();
            values = &stack_pointer[-oparg];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *set_o = PySet_New(NULL);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (set_o == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp;
                for (int _i = oparg; --_i >= 0;) {
                    tmp = values[_i];
                    values[_i] = PyStackRef_NULL;
                    PyStackRef_CLOSE(tmp);
                }
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -oparg;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            int err = 0;
            for (Py_ssize_t i = 0; i < oparg; i++) {
                _PyStackRef value = values[i];
                values[i] = PyStackRef_NULL;
                if (err == 0) {
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    err = _PySet_AddTakeRef((PySetObject *)set_o, PyStackRef_AsPyObjectSteal(value));
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                }
                else {
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    PyStackRef_CLOSE(value);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                }
            }
            if (err) {
                stack_pointer += -oparg;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                Py_DECREF(set_o);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            set = PyStackRef_FromPyObjectStealMortal(set_o);
            _tos_cache0 = set;
            stack_pointer += -oparg;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BUILD_MAP_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *values;
            _PyStackRef map;
            oparg = CURRENT_OPARG();
            values = &stack_pointer[-oparg*2];
            STACKREFS_TO_PYOBJECTS(values, oparg*2, values_o);
            if (CONVERSION_FAILED(values_o)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp;
                for (int _i = oparg*2; --_i >= 0;) {
                    tmp = values[_i];
                    values[_i] = PyStackRef_NULL;
                    PyStackRef_CLOSE(tmp);
                }
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -oparg*2;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *map_o = _PyDict_FromItems(
                values_o, 2,
                values_o+1, 2,
                oparg);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            STACKREFS_TO_PYOBJECTS_CLEANUP(values_o);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp;
            for (int _i = oparg*2; --_i >= 0;) {
                tmp = values[_i];
                values[_i] = PyStackRef_NULL;
                PyStackRef_CLOSE(tmp);
            }
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -oparg*2;
            assert(WITHIN_STACK_BOUNDS());
            if (map_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            map = PyStackRef_FromPyObjectStealMortal(map_o);
            _tos_cache0 = map;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _SETUP_ANNOTATIONS_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            PyObject *ann_dict;
            if (LOCALS() == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyErr_Format(tstate, PyExc_SystemError,
                              "no locals found when setting up annotations");
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = PyMapping_GetOptionalItem(LOCALS(), &_Py_ID(__annotations__), &ann_dict);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            if (ann_dict == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                ann_dict = PyDict_New();
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (ann_dict == NULL) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                _PyFrame_SetStackPointer(frame, stack_pointer);
                err = PyObject_SetItem(LOCALS(), &_Py_ID(__annotations__),
                                       ann_dict);
                Py_DECREF(ann_dict);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (err) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
            }
            else {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                Py_DECREF(ann_dict);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _DICT_UPDATE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef update;
            _PyStackRef dict;
            oparg = CURRENT_OPARG();
            update = stack_pointer[-1];
            dict = stack_pointer[-2 - (oparg - 1)];
            PyObject *dict_o = PyStackRef_AsPyObjectBorrowNonInt(dict);
            PyObject *update_o = PyStackRef_AsPyObjectBorrowed(&update);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = PyDict_Update(dict_o, update_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err < 0) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                int matches = _PyErr_ExceptionMatches(tstate, PyExc_AttributeError);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (matches) {
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    _PyErr_Format(tstate, PyExc_TypeError,
                                  "'%.200s' object is not a mapping",
                                  Py_TYPE(update_o)->tp_name);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                }
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(update);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(update);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _DICT_MERGE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef update;
            _PyStackRef dict;
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            update = stack_pointer[-1];
            dict = stack_pointer[-2 - (oparg - 1)];
            callable = stack_pointer[-5 - (oparg - 1)];
            PyObject *dict_o = PyStackRef_AsPyObjectBorrowNonInt(dict);
            PyObject *update_o = PyStackRef_AsPyObjectBorrowed(&update);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = _PyDict_MergeEx(dict_o, update_o, 2);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err < 0) {
                PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyEval_FormatKwargsError(tstate, callable_o, update_o);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(update);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(update);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _MAP_ADD_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            _PyStackRef key;
            _PyStackRef dict_st;
            oparg = CURRENT_OPARG();
            value = stack_pointer[-1];
            key = stack_pointer[-2];
            dict_st = stack_pointer[-3 - (oparg - 1)];
            PyObject *dict = PyStackRef_AsPyObjectBorrowNonInt(dict_st);
            assert(PyDict_CheckExact(dict));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = _PyDict_SetItem_Take2(
                (PyDictObject *)dict,
                PyStackRef_AsPyObjectSteal(key),
                PyStackRef_AsPyObjectSteal(value)
            );
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err != 0) {
                stack_pointer += -2;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _LOAD_SUPER_ATTR_ATTR_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef self_st;
            _PyStackRef class_st;
            _PyStackRef global_super_st;
            _PyStackRef attr_st;
            oparg = CURRENT_OPARG();
            self_st = stack_pointer[-1];
            class_st = stack_pointer[-2];
            global_super_st = stack_pointer[-3];
            PyObject *global_super = PyStackRef_AsPyObjectBorrowed(&global_super_st);
            if (!PyStackRef_TypeCheck(class_st)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *class = PyStackRef_AsPyObjectBorrowNonInt(class_st);
            PyObject *self = PyStackRef_AsPyObjectBorrowed(&self_st);
            assert(!(oparg & 1));
            if (global_super != (PyObject *)&PySuper_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(LOAD_SUPER_ATTR, hit);
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 2);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *attr = _PySuper_Lookup((PyTypeObject *)class, self, name, NULL);
            _PyStackRef tmp = self_st;
            self_st = PyStackRef_NULL;
            stack_pointer[-1] = self_st;
            PyStackRef_CLOSE(tmp);
            tmp = class_st;
            class_st = PyStackRef_NULL;
            stack_pointer[-2] = class_st;
            PyStackRef_CLOSE(tmp);
            tmp = global_super_st;
            global_super_st = PyStackRef_NULL;
            stack_pointer[-3] = global_super_st;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            if (attr == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            attr_st = PyStackRef_FromPyObjectSteal(attr);
            _tos_cache0 = attr_st;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_SUPER_ATTR_METHOD_r02: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef self_st;
            _PyStackRef class_st;
            _PyStackRef global_super_st;
            _PyStackRef attr;
            _PyStackRef self_or_null;
            oparg = CURRENT_OPARG();
            self_st = stack_pointer[-1];
            class_st = stack_pointer[-2];
            global_super_st = stack_pointer[-3];
            PyObject *global_super = PyStackRef_AsPyObjectBorrowed(&global_super_st);
            if (!PyStackRef_TypeCheck(class_st)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *class = PyStackRef_AsPyObjectBorrowNonInt(class_st);
            PyObject *self = PyStackRef_AsPyObjectBorrowed(&self_st);
            assert(oparg & 1);
            if (global_super != (PyObject *)&PySuper_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(LOAD_SUPER_ATTR, hit);
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 2);
            PyTypeObject *cls = (PyTypeObject *)class;
            int method_found = 0;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *attr_o = _PySuper_Lookup(cls, self, name,
                Py_TYPE(self)->tp_getattro == PyObject_GenericGetAttr ? &method_found : NULL);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (attr_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            if (method_found) {
                self_or_null = self_st;
            } else {
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(self_st);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                self_or_null = PyStackRef_NULL;
                stack_pointer += 1;
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp = global_super_st;
            global_super_st = self_or_null;
            stack_pointer[-2] = global_super_st;
            PyStackRef_CLOSE(tmp);
            tmp = class_st;
            class_st = PyStackRef_NULL;
            stack_pointer[-1] = class_st;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            attr = PyStackRef_FromPyObjectSteal(attr_o);
            _tos_cache1 = self_or_null;
            _tos_cache0 = attr;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_ATTR_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef *self_or_null;
            oparg = CURRENT_OPARG();
            owner = stack_pointer[-1];
            self_or_null = &stack_pointer[0];
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 1);
            PyObject *attr_o;
            if (oparg & 1) {
                attr_o = NULL;
                _PyFrame_SetStackPointer(frame, stack_pointer);
                int is_meth = _PyObject_GetMethod(PyStackRef_AsPyObjectBorrowed(&owner), name, &attr_o);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (is_meth) {
                    assert(attr_o != NULL);
                    self_or_null[0] = owner;
                }
                else {
                    stack_pointer += -1;
                    assert(WITHIN_STACK_BOUNDS());
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    PyStackRef_CLOSE(owner);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                    if (attr_o == NULL) {
                        SET_CURRENT_CACHED_VALUES(0);
                        JUMP_TO_ERROR();
                    }
                    self_or_null[0] = PyStackRef_NULL;
                    stack_pointer += 1;
                }
            }
            else {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                attr_o = PyObject_GetAttr(PyStackRef_AsPyObjectBorrowed(&owner), name);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(owner);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (attr_o == NULL) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                stack_pointer += 1;
            }
            attr = PyStackRef_FromPyObjectSteal(attr_o);
            stack_pointer[-1] = attr;
            stack_pointer += (oparg&1);
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_TYPE_VERSION_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            PyTypeObject *tp = PyStackRef_TYPE(owner);
            assert(type_version != 0);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(tp->tp_version_tag) != type_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = owner;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_TYPE_VERSION_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            owner = stack_pointer[-1];
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            PyTypeObject *tp = PyStackRef_TYPE(owner);
            assert(type_version != 0);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(tp->tp_version_tag) != type_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_TYPE_VERSION_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            owner = _stack_item_1;
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            PyTypeObject *tp = PyStackRef_TYPE(owner);
            assert(type_version != 0);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(tp->tp_version_tag) != type_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = owner;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_TYPE_VERSION_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            owner = _stack_item_2;
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            PyTypeObject *tp = PyStackRef_TYPE(owner);
            assert(type_version != 0);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(tp->tp_version_tag) != type_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = owner;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_TYPE_VERSION_AND_LOCK_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowed(&owner);
            assert(type_version != 0);
            if (!LOCK_OBJECT(owner_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            PyTypeObject *tp = Py_TYPE(owner_o);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(tp->tp_version_tag) != type_version) {
                UNLOCK_OBJECT(owner_o);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(1);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            _tos_cache0 = owner;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_TYPE_VERSION_AND_LOCK_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            owner = stack_pointer[-1];
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowed(&owner);
            assert(type_version != 0);
            if (!LOCK_OBJECT(owner_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyTypeObject *tp = Py_TYPE(owner_o);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(tp->tp_version_tag) != type_version) {
                UNLOCK_OBJECT(owner_o);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            stack_pointer[-1] = owner;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_TYPE_VERSION_AND_LOCK_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            owner = _stack_item_1;
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowed(&owner);
            assert(type_version != 0);
            if (!LOCK_OBJECT(owner_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            PyTypeObject *tp = Py_TYPE(owner_o);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(tp->tp_version_tag) != type_version) {
                UNLOCK_OBJECT(owner_o);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(2);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            _tos_cache1 = owner;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_TYPE_VERSION_AND_LOCK_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            owner = _stack_item_2;
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowed(&owner);
            assert(type_version != 0);
            if (!LOCK_OBJECT(owner_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            PyTypeObject *tp = Py_TYPE(owner_o);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(tp->tp_version_tag) != type_version) {
                UNLOCK_OBJECT(owner_o);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(3);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            _tos_cache2 = owner;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CHECK_MANAGED_OBJECT_HAS_VALUES_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_dictoffset < 0);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            if (!FT_ATOMIC_LOAD_UINT8(_PyObject_InlineValues(owner_o)->valid)) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = owner;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_MANAGED_OBJECT_HAS_VALUES_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            owner = stack_pointer[-1];
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_dictoffset < 0);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            if (!FT_ATOMIC_LOAD_UINT8(_PyObject_InlineValues(owner_o)->valid)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_MANAGED_OBJECT_HAS_VALUES_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            owner = _stack_item_1;
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_dictoffset < 0);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            if (!FT_ATOMIC_LOAD_UINT8(_PyObject_InlineValues(owner_o)->valid)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = owner;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = owner;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _CHECK_MANAGED_OBJECT_HAS_VALUES_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            owner = _stack_item_2;
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_dictoffset < 0);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            if (!FT_ATOMIC_LOAD_UINT8(_PyObject_InlineValues(owner_o)->valid)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = owner;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = owner;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_ATTR_INSTANCE_VALUE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            uint16_t offset = (uint16_t)CURRENT_OPERAND0();
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            PyObject **value_ptr = (PyObject**)(((char *)owner_o) + offset);
            PyObject *attr_o = FT_ATOMIC_LOAD_PTR_ACQUIRE(*value_ptr);
            if (attr_o == NULL) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            int increfed = _Py_TryIncrefCompareStackRef(value_ptr, attr_o, &attr);
            if (!increfed) {
                if (true) {
                    stack_pointer[0] = owner;
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            #else
            attr = PyStackRef_FromPyObjectNew(attr_o);
            #endif
            STAT_INC(LOAD_ATTR, hit);
            stack_pointer[0] = attr;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(owner);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = attr;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_ATTR_MODULE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            uint32_t dict_version = (uint32_t)CURRENT_OPERAND0();
            uint16_t index = (uint16_t)CURRENT_OPERAND1();
            if (PyStackRef_IsTaggedInt(owner)) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            if (Py_TYPE(owner_o)->tp_getattro != PyModule_Type.tp_getattro) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyDictObject *dict = (PyDictObject *)((PyModuleObject *)owner_o)->md_dict;
            assert(dict != NULL);
            PyDictKeysObject *keys = FT_ATOMIC_LOAD_PTR_ACQUIRE(dict->ma_keys);
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(keys->dk_version) != dict_version) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(keys->dk_kind == DICT_KEYS_UNICODE);
            assert(index < FT_ATOMIC_LOAD_SSIZE_RELAXED(keys->dk_nentries));
            PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(keys) + index;
            PyObject *attr_o = FT_ATOMIC_LOAD_PTR_RELAXED(ep->me_value);
            if (attr_o == NULL) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            int increfed = _Py_TryIncrefCompareStackRef(&ep->me_value, attr_o, &attr);
            if (!increfed) {
                if (true) {
                    stack_pointer[0] = owner;
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            #else
            attr = PyStackRef_FromPyObjectNew(attr_o);
            #endif
            STAT_INC(LOAD_ATTR, hit);
            stack_pointer[0] = attr;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(owner);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = attr;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_ATTR_WITH_HINT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            owner = _stack_item_0;
            uint16_t hint = (uint16_t)CURRENT_OPERAND0();
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_MANAGED_DICT);
            PyDictObject *dict = _PyObject_GetManagedDict(owner_o);
            if (dict == NULL) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyDictKeysObject *dk = FT_ATOMIC_LOAD_PTR(dict->ma_keys);
            assert(PyDict_CheckExact((PyObject *)dict));
            #ifdef Py_GIL_DISABLED
            if (!_Py_IsOwnedByCurrentThread((PyObject *)dict) && !_PyObject_GC_IS_SHARED(dict)) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            PyObject *attr_o;
            if (hint >= (size_t)FT_ATOMIC_LOAD_SSIZE_RELAXED(dk->dk_nentries)) {
                if (true) {
                    stack_pointer[0] = owner;
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);
            if (dk->dk_kind != DICT_KEYS_UNICODE) {
                if (true) {
                    stack_pointer[0] = owner;
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dk) + hint;
            if (FT_ATOMIC_LOAD_PTR_RELAXED(ep->me_key) != name) {
                if (true) {
                    stack_pointer[0] = owner;
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            attr_o = FT_ATOMIC_LOAD_PTR(ep->me_value);
            if (attr_o == NULL) {
                if (true) {
                    stack_pointer[0] = owner;
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            STAT_INC(LOAD_ATTR, hit);
            #ifdef Py_GIL_DISABLED
            int increfed = _Py_TryIncrefCompareStackRef(&ep->me_value, attr_o, &attr);
            if (!increfed) {
                if (true) {
                    stack_pointer[0] = owner;
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            #else
            attr = PyStackRef_FromPyObjectNew(attr_o);
            #endif
            stack_pointer[0] = attr;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(owner);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = attr;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_ATTR_SLOT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            uint16_t index = (uint16_t)CURRENT_OPERAND0();
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            PyObject **addr = (PyObject **)((char *)owner_o + index);
            PyObject *attr_o = FT_ATOMIC_LOAD_PTR(*addr);
            if (attr_o == NULL) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            int increfed = _Py_TryIncrefCompareStackRef(addr, attr_o, &attr);
            if (!increfed) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #else
            attr = PyStackRef_FromPyObjectNew(attr_o);
            #endif
            STAT_INC(LOAD_ATTR, hit);
            stack_pointer[0] = owner;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp = owner;
            owner = attr;
            stack_pointer[-1] = owner;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = attr;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_ATTR_CLASS_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            if (PyStackRef_IsTaggedInt(owner)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            if (!PyType_Check(owner_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            assert(type_version != 0);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(((PyTypeObject *)owner_o)->tp_version_tag) != type_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = owner;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_ATTR_CLASS_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            owner = stack_pointer[-1];
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            if (PyStackRef_IsTaggedInt(owner)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            if (!PyType_Check(owner_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(type_version != 0);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(((PyTypeObject *)owner_o)->tp_version_tag) != type_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_ATTR_CLASS_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            owner = _stack_item_1;
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            if (PyStackRef_IsTaggedInt(owner)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            if (!PyType_Check(owner_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            assert(type_version != 0);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(((PyTypeObject *)owner_o)->tp_version_tag) != type_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = owner;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _CHECK_ATTR_CLASS_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            owner = _stack_item_2;
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            if (PyStackRef_IsTaggedInt(owner)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            if (!PyType_Check(owner_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            assert(type_version != 0);
            if (FT_ATOMIC_LOAD_UINT_RELAXED(((PyTypeObject *)owner_o)->tp_version_tag) != type_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = owner;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_ATTR_CLASS_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            attr = PyStackRef_FromPyObjectNew(descr);
            stack_pointer[0] = owner;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp = owner;
            owner = attr;
            stack_pointer[-1] = owner;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = attr;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_ATTR_PROPERTY_FRAME_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef new_frame;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            owner = _stack_item_0;
            PyObject *fget = (PyObject *)CURRENT_OPERAND0();
            assert((oparg & 1) == 0);
            assert(Py_IS_TYPE(fget, &PyFunction_Type));
            PyFunctionObject *f = (PyFunctionObject *)fget;
            PyCodeObject *code = (PyCodeObject *)f->func_code;
            if ((code->co_flags & (CO_VARKEYWORDS | CO_VARARGS | CO_OPTIMIZED)) != CO_OPTIMIZED) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (code->co_kwonlyargcount) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (code->co_argcount != 1) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (!_PyThreadState_HasStackSpace(tstate, code->co_framesize)) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(LOAD_ATTR, hit);
            _PyInterpreterFrame *pushed_frame = _PyFrame_PushUnchecked(tstate, PyStackRef_FromPyObjectNew(fget), 1, frame);
            pushed_frame->localsplus[0] = owner;
            new_frame = PyStackRef_Wrap(pushed_frame);
            _tos_cache0 = new_frame;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        /* _LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN is not a viable micro-op for tier 2 because it has too many cache entries */

        case _GUARD_DORV_NO_DICT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_dictoffset < 0);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            if (_PyObject_GetManagedDict(owner_o) ||
                !FT_ATOMIC_LOAD_UINT8(_PyObject_InlineValues(owner_o)->valid)) {
                UNLOCK_OBJECT(owner_o);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(1);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            _tos_cache0 = owner;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_DORV_NO_DICT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            owner = stack_pointer[-1];
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_dictoffset < 0);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            if (_PyObject_GetManagedDict(owner_o) ||
                !FT_ATOMIC_LOAD_UINT8(_PyObject_InlineValues(owner_o)->valid)) {
                UNLOCK_OBJECT(owner_o);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_DORV_NO_DICT_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            owner = _stack_item_1;
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_dictoffset < 0);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            if (_PyObject_GetManagedDict(owner_o) ||
                !FT_ATOMIC_LOAD_UINT8(_PyObject_InlineValues(owner_o)->valid)) {
                UNLOCK_OBJECT(owner_o);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(2);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            _tos_cache1 = owner;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_DORV_NO_DICT_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            owner = _stack_item_2;
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_dictoffset < 0);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            if (_PyObject_GetManagedDict(owner_o) ||
                !FT_ATOMIC_LOAD_UINT8(_PyObject_InlineValues(owner_o)->valid)) {
                UNLOCK_OBJECT(owner_o);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(3);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            _tos_cache2 = owner;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _STORE_ATTR_INSTANCE_VALUE_r20: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            owner = _stack_item_1;
            value = _stack_item_0;
            uint16_t offset = (uint16_t)CURRENT_OPERAND0();
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            STAT_INC(STORE_ATTR, hit);
            assert(_PyObject_GetManagedDict(owner_o) == NULL);
            PyObject **value_ptr = (PyObject**)(((char *)owner_o) + offset);
            PyObject *old_value = *value_ptr;
            FT_ATOMIC_STORE_PTR_RELEASE(*value_ptr, PyStackRef_AsPyObjectSteal(value));
            if (old_value == NULL) {
                PyDictValues *values = _PyObject_InlineValues(owner_o);
                Py_ssize_t index = value_ptr - values->values;
                _PyDictValues_AddToInsertionOrder(values, index);
            }
            UNLOCK_OBJECT(owner_o);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(owner);
            Py_XDECREF(old_value);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_ATTR_WITH_HINT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            owner = stack_pointer[-1];
            value = stack_pointer[-2];
            uint16_t hint = (uint16_t)CURRENT_OPERAND0();
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_MANAGED_DICT);
            PyDictObject *dict = _PyObject_GetManagedDict(owner_o);
            if (dict == NULL) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (!LOCK_OBJECT(dict)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            if (dict != _PyObject_GetManagedDict(owner_o)) {
                UNLOCK_OBJECT(dict);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            #endif
            assert(PyDict_CheckExact((PyObject *)dict));
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            if (hint >= (size_t)dict->ma_keys->dk_nentries ||
                !DK_IS_UNICODE(dict->ma_keys)) {
                UNLOCK_OBJECT(dict);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + hint;
            if (ep->me_key != name) {
                UNLOCK_OBJECT(dict);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            PyObject *old_value = ep->me_value;
            if (old_value == NULL) {
                UNLOCK_OBJECT(dict);
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            PyObject *value_o = PyStackRef_AsPyObjectBorrowed(&value);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyDict_NotifyEvent(tstate->interp, PyDict_EVENT_MODIFIED, dict, name, value_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            FT_ATOMIC_STORE_PTR_RELEASE(ep->me_value, PyStackRef_AsPyObjectSteal(value));
            UNLOCK_OBJECT(dict);
            STAT_INC(STORE_ATTR, hit);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(owner);
            Py_XDECREF(old_value);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _STORE_ATTR_SLOT_r20: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            owner = _stack_item_1;
            value = _stack_item_0;
            uint16_t index = (uint16_t)CURRENT_OPERAND0();
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            if (!LOCK_OBJECT(owner_o)) {
                stack_pointer[0] = value;
                stack_pointer[1] = owner;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            char *addr = (char *)owner_o + index;
            STAT_INC(STORE_ATTR, hit);
            PyObject *old_value = *(PyObject **)addr;
            FT_ATOMIC_STORE_PTR_RELEASE(*(PyObject **)addr, PyStackRef_AsPyObjectSteal(value));
            UNLOCK_OBJECT(owner_o);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(owner);
            Py_XDECREF(old_value);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _COMPARE_OP_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            PyObject *left_o = PyStackRef_AsPyObjectBorrowed(&left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowed(&right);
            assert((oparg >> 5) <= Py_GE);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = PyObject_RichCompare(left_o, right_o, oparg >> 5);
            _PyStackRef tmp = right;
            right = PyStackRef_NULL;
            stack_pointer[-1] = right;
            PyStackRef_CLOSE(tmp);
            tmp = left;
            left = PyStackRef_NULL;
            stack_pointer[-2] = left;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            if (oparg & 16) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                int res_bool = PyObject_IsTrue(res_o);
                Py_DECREF(res_o);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (res_bool < 0) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                res = res_bool ? PyStackRef_True : PyStackRef_False;
            }
            else {
                res = PyStackRef_FromPyObjectSteal(res_o);
            }
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _COMPARE_OP_FLOAT_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            right = _stack_item_1;
            left = _stack_item_0;
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            STAT_INC(COMPARE_OP, hit);
            double dleft = PyFloat_AS_DOUBLE(left_o);
            double dright = PyFloat_AS_DOUBLE(right_o);
            int sign_ish = COMPARISON_BIT(dleft, dright);
            PyStackRef_CLOSE_SPECIALIZED(left, _PyFloat_ExactDealloc);
            PyStackRef_CLOSE_SPECIALIZED(right, _PyFloat_ExactDealloc);
            res = (sign_ish & oparg) ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _COMPARE_OP_INT_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            right = _stack_item_1;
            left = _stack_item_0;
            intptr_t ileft = PyStackRef_UntagInt(left);
            intptr_t iright = PyStackRef_UntagInt(right);
            int sign_ish = COMPARISON_BIT(ileft, iright);
            res =  (sign_ish & oparg) ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _COMPARE_OP_INT_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            right = _stack_item_0;
            left = stack_pointer[-1];
            intptr_t ileft = PyStackRef_UntagInt(left);
            intptr_t iright = PyStackRef_UntagInt(right);
            int sign_ish = COMPARISON_BIT(ileft, iright);
            res =  (sign_ish & oparg) ? PyStackRef_True : PyStackRef_False;
            stack_pointer[-1] = res;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _COMPARE_OP_INT_r32: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            oparg = CURRENT_OPARG();
            right = _stack_item_2;
            left = _stack_item_1;
            intptr_t ileft = PyStackRef_UntagInt(left);
            intptr_t iright = PyStackRef_UntagInt(right);
            int sign_ish = COMPARISON_BIT(ileft, iright);
            res =  (sign_ish & oparg) ? PyStackRef_True : PyStackRef_False;
            _tos_cache1 = res;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _COMPARE_OP_STR_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            right = _stack_item_1;
            left = _stack_item_0;
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            STAT_INC(COMPARE_OP, hit);
            int eq = _PyUnicode_Equal(left_o, right_o);
            assert((oparg >> 5) == Py_EQ || (oparg >> 5) == Py_NE);
            PyStackRef_CLOSE_SPECIALIZED(left, _PyUnicode_ExactDealloc);
            PyStackRef_CLOSE_SPECIALIZED(right, _PyUnicode_ExactDealloc);
            assert(eq == 0 || eq == 1);
            assert((oparg & 0xf) == COMPARISON_NOT_EQUALS || (oparg & 0xf) == COMPARISON_EQUALS);
            assert(COMPARISON_NOT_EQUALS + 1 == COMPARISON_EQUALS);
            res = ((COMPARISON_NOT_EQUALS + eq) & oparg) ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _IS_OP_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef b;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            right = _stack_item_1;
            left = _stack_item_0;
            int res = PyStackRef_Is(left, right) ^ oparg;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp = right;
            right = PyStackRef_NULL;
            stack_pointer[0] = left;
            stack_pointer[1] = right;
            PyStackRef_CLOSE(tmp);
            tmp = left;
            left = PyStackRef_NULL;
            stack_pointer[0] = left;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            b = res ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = b;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CONTAINS_OP_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef b;
            oparg = CURRENT_OPARG();
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            PyObject *left_o = PyStackRef_AsPyObjectBorrowed(&left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowed(&right);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int res = PySequence_Contains(right_o, left_o);
            _PyStackRef tmp = right;
            right = PyStackRef_NULL;
            stack_pointer[-1] = right;
            PyStackRef_CLOSE(tmp);
            tmp = left;
            left = PyStackRef_NULL;
            stack_pointer[-2] = left;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (res < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            b = (res ^ oparg) ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = b;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_TOS_ANY_SET_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            tos = _stack_item_0;
            if (!PyStackRef_AnySetCheckExact(tos)) {
                stack_pointer[0] = tos;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = tos;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_TOS_ANY_SET_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef tos;
            tos = stack_pointer[-1];
            if (!PyStackRef_AnySetCheckExact(tos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_TOS_ANY_SET_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            tos = _stack_item_1;
            if (!PyStackRef_AnySetCheckExact(tos)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = tos;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = tos;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_TOS_ANY_SET_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef tos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            tos = _stack_item_2;
            if (!PyStackRef_AnySetCheckExact(tos)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = tos;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = tos;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CONTAINS_OP_SET_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef b;
            oparg = CURRENT_OPARG();
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            PyObject *left_o = PyStackRef_AsPyObjectBorrowed(&left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            assert(PyAnySet_CheckExact(right_o));
            STAT_INC(CONTAINS_OP, hit);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int res = _PySet_Contains((PySetObject *)right_o, left_o);
            _PyStackRef tmp = right;
            right = PyStackRef_NULL;
            stack_pointer[-1] = right;
            PyStackRef_CLOSE(tmp);
            tmp = left;
            left = PyStackRef_NULL;
            stack_pointer[-2] = left;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (res < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            b = (res ^ oparg) ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = b;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CONTAINS_OP_DICT_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef b;
            oparg = CURRENT_OPARG();
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            PyObject *left_o = PyStackRef_AsPyObjectBorrowed(&left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowNonInt(right);
            assert(PyDict_CheckExact(right_o));
            STAT_INC(CONTAINS_OP, hit);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int res = PyDict_Contains(right_o, left_o);
            _PyStackRef tmp = right;
            right = PyStackRef_NULL;
            stack_pointer[-1] = right;
            PyStackRef_CLOSE(tmp);
            tmp = left;
            left = PyStackRef_NULL;
            stack_pointer[-2] = left;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (res < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            b = (res ^ oparg) ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = b;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_EG_MATCH_r02: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef match_type_st;
            _PyStackRef exc_value_st;
            _PyStackRef rest;
            _PyStackRef match;
            match_type_st = stack_pointer[-1];
            exc_value_st = stack_pointer[-2];
            PyObject *exc_value = PyStackRef_AsPyObjectBorrowNonInt(exc_value_st);
            PyObject *match_type = PyStackRef_AsPyObjectBorrowed(&match_type_st);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = _PyEval_CheckExceptStarTypeValid(tstate, match_type);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err < 0) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp = match_type_st;
                match_type_st = PyStackRef_NULL;
                stack_pointer[-1] = match_type_st;
                PyStackRef_CLOSE(tmp);
                tmp = exc_value_st;
                exc_value_st = PyStackRef_NULL;
                stack_pointer[-2] = exc_value_st;
                PyStackRef_CLOSE(tmp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -2;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            PyObject *match_o = NULL;
            PyObject *rest_o = NULL;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int res = _PyEval_ExceptionGroupMatch(frame, exc_value, match_type,
                &match_o, &rest_o);
            _PyStackRef tmp = match_type_st;
            match_type_st = PyStackRef_NULL;
            stack_pointer[-1] = match_type_st;
            PyStackRef_CLOSE(tmp);
            tmp = exc_value_st;
            exc_value_st = PyStackRef_NULL;
            stack_pointer[-2] = exc_value_st;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (res < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            assert((match_o == NULL) == (rest_o == NULL));
            if (match_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            if (!Py_IsNone(match_o)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyErr_SetHandledException(match_o);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            rest = PyStackRef_FromPyObjectSteal(rest_o);
            match = PyStackRef_FromPyObjectSteal(match_o);
            _tos_cache1 = match;
            _tos_cache0 = rest;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _CHECK_EXC_MATCH_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef right;
            _PyStackRef left;
            _PyStackRef b;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            PyObject *left_o = PyStackRef_AsPyObjectBorrowNonInt(left);
            PyObject *right_o = PyStackRef_AsPyObjectBorrowed(&right);
            assert(PyExceptionInstance_Check(left_o));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = _PyEval_CheckExceptTypeValid(tstate, right_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int res = PyErr_GivenExceptionMatches(left_o, right_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(right);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            b = res ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = b;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _IMPORT_NAME_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef fromlist;
            _PyStackRef level;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            fromlist = stack_pointer[-1];
            level = stack_pointer[-2];
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = _PyEval_ImportName(tstate, frame, name,
                PyStackRef_AsPyObjectBorrowNonInt(fromlist),
                PyStackRef_AsPyObjectBorrowed(&level));
            _PyStackRef tmp = fromlist;
            fromlist = PyStackRef_NULL;
            stack_pointer[-1] = fromlist;
            PyStackRef_CLOSE(tmp);
            tmp = level;
            level = PyStackRef_NULL;
            stack_pointer[-2] = level;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _IMPORT_FROM_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef from;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            from = stack_pointer[-1];
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = _PyEval_ImportFrom(tstate, PyStackRef_AsPyObjectBorrowed(&from), name);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (res_o == NULL) {
                stack_pointer[-1] = from;
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            stack_pointer[-1] = from;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        /* _POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 because it is replaced */

        /* _POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 because it is replaced */

        case _IS_NONE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef b;
            _PyStackRef _stack_item_0 = _tos_cache0;
            value = _stack_item_0;
            if (PyStackRef_IsNone(value)) {
                b = PyStackRef_True;
            }
            else {
                b = PyStackRef_False;
                stack_pointer[0] = value;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp = value;
                value = b;
                stack_pointer[-1] = value;
                PyStackRef_CLOSE(tmp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
            }
            _tos_cache0 = b;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GET_LEN_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef obj;
            _PyStackRef len;
            obj = stack_pointer[-1];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            Py_ssize_t len_i = PyObject_Length(PyStackRef_AsPyObjectBorrowed(&obj));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (len_i < 0) {
                stack_pointer[-1] = obj;
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            len = PyStackRef_TagInt(len_i);
            _tos_cache0 = len;
            stack_pointer[-1] = obj;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _MATCH_CLASS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef names;
            _PyStackRef type;
            _PyStackRef subject;
            _PyStackRef attrs;
            oparg = CURRENT_OPARG();
            names = stack_pointer[-1];
            type = stack_pointer[-2];
            subject = stack_pointer[-3];
            assert(PyTuple_CheckExact(PyStackRef_AsPyObjectBorrowNonInt(names)));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *attrs_o = _PyEval_MatchClass(tstate,
                PyStackRef_AsPyObjectBorrowed(&subject),
                PyStackRef_AsPyObjectBorrowed(&type), oparg,
                PyStackRef_AsPyObjectBorrowNonInt(names));
            _PyStackRef tmp = names;
            names = PyStackRef_NULL;
            stack_pointer[-1] = names;
            PyStackRef_CLOSE(tmp);
            tmp = type;
            type = PyStackRef_NULL;
            stack_pointer[-2] = type;
            PyStackRef_CLOSE(tmp);
            tmp = subject;
            subject = PyStackRef_NULL;
            stack_pointer[-3] = subject;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            if (attrs_o) {
                assert(PyTuple_CheckExact(attrs_o));
                _PyFrame_SetStackPointer(frame, stack_pointer);
                attrs = PyStackRef_FromPyObjectStealNonInt(attrs_o);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            else {
                if (_PyErr_Occurred(tstate)) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                attrs = PyStackRef_None;
            }
            _tos_cache0 = attrs;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _MATCH_MAPPING_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef subject;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            subject = _stack_item_0;
            int match = PyStackRef_TYPE(subject)->tp_flags & Py_TPFLAGS_MAPPING;
            res = match ? PyStackRef_True : PyStackRef_False;
            _tos_cache1 = res;
            _tos_cache0 = subject;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _MATCH_MAPPING_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef subject;
            _PyStackRef res;
            subject = stack_pointer[-1];
            int match = PyStackRef_TYPE(subject)->tp_flags & Py_TPFLAGS_MAPPING;
            res = match ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _MATCH_MAPPING_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef subject;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            subject = _stack_item_1;
            int match = PyStackRef_TYPE(subject)->tp_flags & Py_TPFLAGS_MAPPING;
            res = match ? PyStackRef_True : PyStackRef_False;
            _tos_cache2 = res;
            _tos_cache1 = subject;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _MATCH_SEQUENCE_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef subject;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            subject = _stack_item_0;
            int match = PyStackRef_TYPE(subject)->tp_flags & Py_TPFLAGS_SEQUENCE;
            res = match ? PyStackRef_True : PyStackRef_False;
            _tos_cache1 = res;
            _tos_cache0 = subject;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _MATCH_SEQUENCE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef subject;
            _PyStackRef res;
            subject = stack_pointer[-1];
            int match = PyStackRef_TYPE(subject)->tp_flags & Py_TPFLAGS_SEQUENCE;
            res = match ? PyStackRef_True : PyStackRef_False;
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _MATCH_SEQUENCE_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef subject;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            subject = _stack_item_1;
            int match = PyStackRef_TYPE(subject)->tp_flags & Py_TPFLAGS_SEQUENCE;
            res = match ? PyStackRef_True : PyStackRef_False;
            _tos_cache2 = res;
            _tos_cache1 = subject;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _MATCH_KEYS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef keys;
            _PyStackRef subject;
            _PyStackRef values_or_none;
            keys = stack_pointer[-1];
            subject = stack_pointer[-2];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *values_or_none_o = _PyEval_MatchKeys(tstate,
                PyStackRef_AsPyObjectBorrowed(&subject), PyStackRef_AsPyObjectBorrowed(&keys));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (values_or_none_o == NULL) {
                stack_pointer[-2] = subject;
                stack_pointer[-1] = keys;
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            values_or_none = PyStackRef_FromPyObjectSteal(values_or_none_o);
            _tos_cache0 = values_or_none;
            stack_pointer[-2] = subject;
            stack_pointer[-1] = keys;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GET_ITER_r02: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef iterable;
            _PyStackRef iter;
            _PyStackRef index_or_null;
            iterable = stack_pointer[-1];
            #ifdef Py_STATS
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _Py_GatherStats_GetIter(iterable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            #endif

            PyTypeObject *tp = PyStackRef_TYPE(iterable);
            if (tp == &PyTuple_Type || tp == &PyList_Type) {
                iter = iterable;
                index_or_null = PyStackRef_TagInt(0);
            }
            else {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyObject *iter_o = PyObject_GetIter(PyStackRef_AsPyObjectBorrowed(&iterable));
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(iterable);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (iter_o == NULL) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                iter = PyStackRef_FromPyObjectSteal(iter_o);
                index_or_null = PyStackRef_NULL;
                stack_pointer += 1;
            }
            _tos_cache1 = index_or_null;
            _tos_cache0 = iter;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GET_YIELD_FROM_ITER_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef iterable;
            _PyStackRef iter;
            iterable = stack_pointer[-1];
            PyObject *iterable_o = PyStackRef_AsPyObjectBorrowed(&iterable);
            if (PyCoro_CheckExact(iterable_o)) {
                if (!(_PyFrame_GetCode(frame)->co_flags & (CO_COROUTINE | CO_ITERABLE_COROUTINE))) {
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    _PyErr_SetString(tstate, PyExc_TypeError,
                                     "cannot 'yield from' a coroutine object "
                                     "in a non-coroutine generator");
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                iter = iterable;
            }
            else if (PyGen_CheckExact(iterable_o)) {
                iter = iterable;
            }
            else {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyObject *iter_o = PyObject_GetIter(iterable_o);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (iter_o == NULL) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                iter = PyStackRef_FromPyObjectSteal(iter_o);
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp = iterable;
                iterable = iter;
                stack_pointer[-1] = iterable;
                PyStackRef_CLOSE(tmp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            _tos_cache0 = iter;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        /* _FOR_ITER is not a viable micro-op for tier 2 because it is replaced */

        case _FOR_ITER_TIER_TWO_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef next;
            null_or_index = stack_pointer[-1];
            iter = stack_pointer[-2];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef item = _PyForIter_VirtualIteratorNext(tstate, frame, iter, &null_or_index);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (!PyStackRef_IsValid(item)) {
                if (PyStackRef_IsError(item)) {
                    stack_pointer[-1] = null_or_index;
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            next = item;
            _tos_cache0 = next;
            stack_pointer[-1] = null_or_index;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        /* _INSTRUMENTED_FOR_ITER is not a viable micro-op for tier 2 because it is instrumented */

        case _ITER_CHECK_LIST_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            null_or_index = _stack_item_1;
            iter = _stack_item_0;
            if (PyStackRef_TYPE(iter) != &PyList_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            assert(PyStackRef_IsTaggedInt(null_or_index));
            #ifdef Py_GIL_DISABLED
            PyObject *iter_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            if (!_Py_IsOwnedByCurrentThread(iter_o) && !_PyObject_GC_IS_SHARED(iter_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache1 = null_or_index;
            _tos_cache0 = iter;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _ITER_CHECK_LIST_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            null_or_index = stack_pointer[-1];
            iter = stack_pointer[-2];
            if (PyStackRef_TYPE(iter) != &PyList_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(PyStackRef_IsTaggedInt(null_or_index));
            #ifdef Py_GIL_DISABLED
            PyObject *iter_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            if (!_Py_IsOwnedByCurrentThread(iter_o) && !_PyObject_GC_IS_SHARED(iter_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _ITER_CHECK_LIST_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            null_or_index = _stack_item_0;
            iter = stack_pointer[-1];
            if (PyStackRef_TYPE(iter) != &PyList_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            assert(PyStackRef_IsTaggedInt(null_or_index));
            #ifdef Py_GIL_DISABLED
            PyObject *iter_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            if (!_Py_IsOwnedByCurrentThread(iter_o) && !_PyObject_GC_IS_SHARED(iter_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache0 = null_or_index;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _ITER_CHECK_LIST_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            null_or_index = _stack_item_2;
            iter = _stack_item_1;
            if (PyStackRef_TYPE(iter) != &PyList_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            assert(PyStackRef_IsTaggedInt(null_or_index));
            #ifdef Py_GIL_DISABLED
            PyObject *iter_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            if (!_Py_IsOwnedByCurrentThread(iter_o) && !_PyObject_GC_IS_SHARED(iter_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache2 = null_or_index;
            _tos_cache1 = iter;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        /* _ITER_JUMP_LIST is not a viable micro-op for tier 2 because it is replaced */

        case _GUARD_NOT_EXHAUSTED_LIST_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            null_or_index = _stack_item_1;
            iter = _stack_item_0;
            #ifndef Py_GIL_DISABLED
            PyObject *list_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(list_o) == &PyList_Type);
            if ((size_t)PyStackRef_UntagInt(null_or_index) >= (size_t)PyList_GET_SIZE(list_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache1 = null_or_index;
            _tos_cache0 = iter;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_LIST_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            null_or_index = stack_pointer[-1];
            iter = stack_pointer[-2];
            #ifndef Py_GIL_DISABLED
            PyObject *list_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(list_o) == &PyList_Type);
            if ((size_t)PyStackRef_UntagInt(null_or_index) >= (size_t)PyList_GET_SIZE(list_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_LIST_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            null_or_index = _stack_item_0;
            iter = stack_pointer[-1];
            #ifndef Py_GIL_DISABLED
            PyObject *list_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(list_o) == &PyList_Type);
            if ((size_t)PyStackRef_UntagInt(null_or_index) >= (size_t)PyList_GET_SIZE(list_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache0 = null_or_index;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_LIST_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            null_or_index = _stack_item_2;
            iter = _stack_item_1;
            #ifndef Py_GIL_DISABLED
            PyObject *list_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(list_o) == &PyList_Type);
            if ((size_t)PyStackRef_UntagInt(null_or_index) >= (size_t)PyList_GET_SIZE(list_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache2 = null_or_index;
            _tos_cache1 = iter;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        /* _ITER_NEXT_LIST is not a viable micro-op for tier 2 because it is replaced */

        case _ITER_NEXT_LIST_TIER_TWO_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef next;
            null_or_index = stack_pointer[-1];
            iter = stack_pointer[-2];
            PyObject *list_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(PyList_CheckExact(list_o));
            #ifdef Py_GIL_DISABLED
            assert(_Py_IsOwnedByCurrentThread((PyObject *)list_o) ||
                  _PyObject_GC_IS_SHARED(list_o));
            STAT_INC(FOR_ITER, hit);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int result = _PyList_GetItemRefNoLock((PyListObject *)list_o, PyStackRef_UntagInt(null_or_index), &next);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (result <= 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #else
            assert(PyStackRef_UntagInt(null_or_index) < PyList_GET_SIZE(list_o));
            next = PyStackRef_FromPyObjectNew(PyList_GET_ITEM(list_o, PyStackRef_UntagInt(null_or_index)));
            #endif
            null_or_index = PyStackRef_IncrementTaggedIntNoOverflow(null_or_index);
            _tos_cache0 = next;
            stack_pointer[-1] = null_or_index;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _ITER_CHECK_TUPLE_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            null_or_index = _stack_item_1;
            iter = _stack_item_0;
            if (!PyStackRef_TupleCheckExact(iter)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            assert(PyStackRef_IsTaggedInt(null_or_index));
            _tos_cache1 = null_or_index;
            _tos_cache0 = iter;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _ITER_CHECK_TUPLE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            null_or_index = stack_pointer[-1];
            iter = stack_pointer[-2];
            if (!PyStackRef_TupleCheckExact(iter)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(PyStackRef_IsTaggedInt(null_or_index));
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _ITER_CHECK_TUPLE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            null_or_index = _stack_item_0;
            iter = stack_pointer[-1];
            if (!PyStackRef_TupleCheckExact(iter)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            assert(PyStackRef_IsTaggedInt(null_or_index));
            _tos_cache0 = null_or_index;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _ITER_CHECK_TUPLE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            null_or_index = _stack_item_2;
            iter = _stack_item_1;
            if (!PyStackRef_TupleCheckExact(iter)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            assert(PyStackRef_IsTaggedInt(null_or_index));
            _tos_cache2 = null_or_index;
            _tos_cache1 = iter;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        /* _ITER_JUMP_TUPLE is not a viable micro-op for tier 2 because it is replaced */

        case _GUARD_NOT_EXHAUSTED_TUPLE_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            null_or_index = _stack_item_1;
            iter = _stack_item_0;
            PyObject *tuple_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(tuple_o) == &PyTuple_Type);
            if ((size_t)PyStackRef_UntagInt(null_or_index) >= (size_t)PyTuple_GET_SIZE(tuple_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = null_or_index;
            _tos_cache0 = iter;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_TUPLE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            null_or_index = stack_pointer[-1];
            iter = stack_pointer[-2];
            PyObject *tuple_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(tuple_o) == &PyTuple_Type);
            if ((size_t)PyStackRef_UntagInt(null_or_index) >= (size_t)PyTuple_GET_SIZE(tuple_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_TUPLE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            null_or_index = _stack_item_0;
            iter = stack_pointer[-1];
            PyObject *tuple_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(tuple_o) == &PyTuple_Type);
            if ((size_t)PyStackRef_UntagInt(null_or_index) >= (size_t)PyTuple_GET_SIZE(tuple_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = null_or_index;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_TUPLE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            null_or_index = _stack_item_2;
            iter = _stack_item_1;
            PyObject *tuple_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(tuple_o) == &PyTuple_Type);
            if ((size_t)PyStackRef_UntagInt(null_or_index) >= (size_t)PyTuple_GET_SIZE(tuple_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = null_or_index;
            _tos_cache1 = iter;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _ITER_NEXT_TUPLE_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef null_or_index;
            _PyStackRef iter;
            _PyStackRef next;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            null_or_index = _stack_item_1;
            iter = _stack_item_0;
            PyObject *tuple_o = PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(tuple_o) == &PyTuple_Type);
            uintptr_t i = PyStackRef_UntagInt(null_or_index);
            assert((size_t)i < (size_t)PyTuple_GET_SIZE(tuple_o));
            next = PyStackRef_FromPyObjectNew(PyTuple_GET_ITEM(tuple_o, i));
            null_or_index = PyStackRef_IncrementTaggedIntNoOverflow(null_or_index);
            _tos_cache2 = next;
            _tos_cache1 = null_or_index;
            _tos_cache0 = iter;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _ITER_CHECK_RANGE_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            iter = _stack_item_0;
            if (PyStackRef_TYPE(iter) != &PyRangeIter_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            _PyRangeIterObject *r = (_PyRangeIterObject *)PyStackRef_AsPyObjectBorrowNonInt(iter);
            if (!_PyObject_IsUniquelyReferenced((PyObject *)r)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = iter;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _ITER_CHECK_RANGE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef iter;
            iter = stack_pointer[-2];
            if (PyStackRef_TYPE(iter) != &PyRangeIter_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            _PyRangeIterObject *r = (_PyRangeIterObject *)PyStackRef_AsPyObjectBorrowNonInt(iter);
            if (!_PyObject_IsUniquelyReferenced((PyObject *)r)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _ITER_CHECK_RANGE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            iter = stack_pointer[-1];
            if (PyStackRef_TYPE(iter) != &PyRangeIter_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            _PyRangeIterObject *r = (_PyRangeIterObject *)PyStackRef_AsPyObjectBorrowNonInt(iter);
            if (!_PyObject_IsUniquelyReferenced((PyObject *)r)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _ITER_CHECK_RANGE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            iter = _stack_item_1;
            if (PyStackRef_TYPE(iter) != &PyRangeIter_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED
            _PyRangeIterObject *r = (_PyRangeIterObject *)PyStackRef_AsPyObjectBorrowNonInt(iter);
            if (!_PyObject_IsUniquelyReferenced((PyObject *)r)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = iter;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        /* _ITER_JUMP_RANGE is not a viable micro-op for tier 2 because it is replaced */

        case _GUARD_NOT_EXHAUSTED_RANGE_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            iter = _stack_item_0;
            _PyRangeIterObject *r = (_PyRangeIterObject *)PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(r) == &PyRangeIter_Type);
            if (r->len <= 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = iter;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_RANGE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef iter;
            iter = stack_pointer[-2];
            _PyRangeIterObject *r = (_PyRangeIterObject *)PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(r) == &PyRangeIter_Type);
            if (r->len <= 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_RANGE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            iter = stack_pointer[-1];
            _PyRangeIterObject *r = (_PyRangeIterObject *)PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(r) == &PyRangeIter_Type);
            if (r->len <= 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_RANGE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef iter;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            iter = _stack_item_1;
            _PyRangeIterObject *r = (_PyRangeIterObject *)PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(r) == &PyRangeIter_Type);
            if (r->len <= 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = iter;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _ITER_NEXT_RANGE_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef iter;
            _PyStackRef next;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            iter = _stack_item_0;
            _PyRangeIterObject *r = (_PyRangeIterObject *)PyStackRef_AsPyObjectBorrowNonInt(iter);
            assert(Py_TYPE(r) == &PyRangeIter_Type);
            #ifdef Py_GIL_DISABLED
            assert(_PyObject_IsUniquelyReferenced((PyObject *)r));
            #endif
            assert(r->len > 0);
            long value = r->start;
            r->start = value + r->step;
            r->len--;
            next = PyStackRef_TagInt(value);
            _tos_cache2 = next;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = iter;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _FOR_ITER_GEN_FRAME_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef iter;
            _PyStackRef gen_frame;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            iter = _stack_item_0;
            PyGenObject *gen = (PyGenObject *)PyStackRef_AsPyObjectBorrowNonInt(iter);
            if (Py_TYPE(gen) != &PyGen_Type) {
                stack_pointer[0] = iter;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #ifdef Py_GIL_DISABLED

            if (!_PyObject_IsUniquelyReferenced((PyObject *)gen)) {
                stack_pointer[0] = iter;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            #endif
            if (gen->gi_frame_state >= FRAME_EXECUTING) {
                stack_pointer[0] = iter;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(FOR_ITER, hit);
            _PyInterpreterFrame *pushed_frame = &gen->gi_iframe;
            _PyFrame_StackPush(pushed_frame, PyStackRef_None);
            gen->gi_frame_state = FRAME_EXECUTING;
            gen->gi_exc_state.previous_item = tstate->exc_info;
            tstate->exc_info = &gen->gi_exc_state;
            pushed_frame->previous = frame;
            frame->return_offset = (uint16_t)( 2 + oparg);
            gen_frame = PyStackRef_Wrap(pushed_frame);
            _tos_cache2 = gen_frame;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = iter;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _INSERT_NULL_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef self;
            _PyStackRef *method_and_self;
            _PyStackRef _stack_item_0 = _tos_cache0;
            self = _stack_item_0;
            method_and_self = &stack_pointer[0];
            method_and_self[1] = self;
            method_and_self[0] = PyStackRef_NULL;
            stack_pointer += 2;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _LOAD_SPECIAL_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *method_and_self;
            oparg = CURRENT_OPARG();
            method_and_self = &stack_pointer[-2];
            PyObject *name = _Py_SpecialMethods[oparg].name;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int err = _PyObject_LookupSpecialMethod(name, method_and_self);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err <= 0) {
                if (err == 0) {
                    PyObject *owner = PyStackRef_AsPyObjectBorrowed(&method_and_self[1]);
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    const char *errfmt = _PyEval_SpecialMethodCanSuggest(owner, oparg)
                    ? _Py_SpecialMethods[oparg].error_suggestion
                : _Py_SpecialMethods[oparg].error;
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                    assert(!_PyErr_Occurred(tstate));
                    assert(errfmt != NULL);
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    _PyErr_Format(tstate, PyExc_TypeError, errfmt, owner);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                }
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _WITH_EXCEPT_START_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef val;
            _PyStackRef lasti;
            _PyStackRef exit_self;
            _PyStackRef exit_func;
            _PyStackRef res;
            val = stack_pointer[-1];
            lasti = stack_pointer[-3];
            exit_self = stack_pointer[-4];
            exit_func = stack_pointer[-5];
            PyObject *exc, *tb;
            PyObject *val_o = PyStackRef_AsPyObjectBorrowNonInt(val);
            PyObject *exit_func_o = PyStackRef_AsPyObjectBorrowNonInt(exit_func);
            assert(val_o && PyExceptionInstance_Check(val_o));
            exc = PyExceptionInstance_Class(val_o);
            PyObject *original_tb = tb = PyException_GetTraceback(val_o);
            if (tb == NULL) {
                tb = Py_None;
            }
            assert(PyStackRef_IsTaggedInt(lasti));
            (void)lasti;
            PyObject *stack[5] = {NULL, PyStackRef_AsPyObjectBorrowNonInt(exit_self), exc, val_o, tb};
            int has_self = !PyStackRef_IsNull(exit_self);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = PyObject_Vectorcall(exit_func_o, stack + 2 - has_self,
                (3 + has_self) | PY_VECTORCALL_ARGUMENTS_OFFSET, NULL);
            Py_XDECREF(original_tb);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _PUSH_EXC_INFO_r02: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef exc;
            _PyStackRef prev_exc;
            _PyStackRef new_exc;
            exc = stack_pointer[-1];
            _PyErr_StackItem *exc_info = tstate->exc_info;
            if (exc_info->exc_value != NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                prev_exc = PyStackRef_FromPyObjectStealNonInt(exc_info->exc_value);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            else {
                prev_exc = PyStackRef_None;
            }
            assert(PyStackRef_ExceptionInstanceCheck(exc));
            exc_info->exc_value = PyStackRef_AsPyObjectNew(exc);
            new_exc = exc;
            _tos_cache1 = new_exc;
            _tos_cache0 = prev_exc;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            PyDictValues *ivs = _PyObject_InlineValues(owner_o);
            if (!FT_ATOMIC_LOAD_UINT8(ivs->valid)) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = owner;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            owner = stack_pointer[-1];
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            PyDictValues *ivs = _PyObject_InlineValues(owner_o);
            if (!FT_ATOMIC_LOAD_UINT8(ivs->valid)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            owner = _stack_item_1;
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            PyDictValues *ivs = _PyObject_InlineValues(owner_o);
            if (!FT_ATOMIC_LOAD_UINT8(ivs->valid)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = owner;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = owner;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            owner = _stack_item_2;
            PyObject *owner_o = PyStackRef_AsPyObjectBorrowNonInt(owner);
            assert(Py_TYPE(owner_o)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            PyDictValues *ivs = _PyObject_InlineValues(owner_o);
            if (!FT_ATOMIC_LOAD_UINT8(ivs->valid)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = owner;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = owner;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_KEYS_VERSION_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            uint32_t keys_version = (uint32_t)CURRENT_OPERAND0();
            PyTypeObject *owner_cls = Py_TYPE(PyStackRef_AsPyObjectBorrowNonInt(owner));
            PyHeapTypeObject *owner_heap_type = (PyHeapTypeObject *)owner_cls;
            PyDictKeysObject *keys = owner_heap_type->ht_cached_keys;
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(keys->dk_version) != keys_version) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = owner;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_KEYS_VERSION_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            owner = stack_pointer[-1];
            uint32_t keys_version = (uint32_t)CURRENT_OPERAND0();
            PyTypeObject *owner_cls = Py_TYPE(PyStackRef_AsPyObjectBorrowNonInt(owner));
            PyHeapTypeObject *owner_heap_type = (PyHeapTypeObject *)owner_cls;
            PyDictKeysObject *keys = owner_heap_type->ht_cached_keys;
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(keys->dk_version) != keys_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_KEYS_VERSION_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            owner = _stack_item_1;
            uint32_t keys_version = (uint32_t)CURRENT_OPERAND0();
            PyTypeObject *owner_cls = Py_TYPE(PyStackRef_AsPyObjectBorrowNonInt(owner));
            PyHeapTypeObject *owner_heap_type = (PyHeapTypeObject *)owner_cls;
            PyDictKeysObject *keys = owner_heap_type->ht_cached_keys;
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(keys->dk_version) != keys_version) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = owner;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = owner;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_KEYS_VERSION_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            owner = _stack_item_2;
            uint32_t keys_version = (uint32_t)CURRENT_OPERAND0();
            PyTypeObject *owner_cls = Py_TYPE(PyStackRef_AsPyObjectBorrowNonInt(owner));
            PyHeapTypeObject *owner_heap_type = (PyHeapTypeObject *)owner_cls;
            PyDictKeysObject *keys = owner_heap_type->ht_cached_keys;
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(keys->dk_version) != keys_version) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = owner;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = owner;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_ATTR_METHOD_WITH_VALUES_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef self;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            owner = _stack_item_0;
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            assert(oparg & 1);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            attr = PyStackRef_FromPyObjectNew(descr);
            self = owner;
            _tos_cache1 = self;
            _tos_cache0 = attr;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_ATTR_METHOD_WITH_VALUES_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef self;
            oparg = CURRENT_OPARG();
            owner = stack_pointer[-1];
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            assert(oparg & 1);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            attr = PyStackRef_FromPyObjectNew(descr);
            self = owner;
            _tos_cache0 = self;
            stack_pointer[-1] = attr;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_ATTR_METHOD_WITH_VALUES_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef self;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            owner = _stack_item_1;
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            assert(oparg & 1);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            attr = PyStackRef_FromPyObjectNew(descr);
            self = owner;
            _tos_cache2 = self;
            _tos_cache1 = attr;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_ATTR_METHOD_NO_DICT_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef self;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            owner = _stack_item_0;
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            assert(oparg & 1);
            assert(PyStackRef_TYPE(owner)->tp_dictoffset == 0);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            attr = PyStackRef_FromPyObjectNew(descr);
            self = owner;
            _tos_cache1 = self;
            _tos_cache0 = attr;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_ATTR_METHOD_NO_DICT_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef self;
            oparg = CURRENT_OPARG();
            owner = stack_pointer[-1];
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            assert(oparg & 1);
            assert(PyStackRef_TYPE(owner)->tp_dictoffset == 0);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            attr = PyStackRef_FromPyObjectNew(descr);
            self = owner;
            _tos_cache0 = self;
            stack_pointer[-1] = attr;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_ATTR_METHOD_NO_DICT_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef self;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            owner = _stack_item_1;
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            assert(oparg & 1);
            assert(PyStackRef_TYPE(owner)->tp_dictoffset == 0);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            attr = PyStackRef_FromPyObjectNew(descr);
            self = owner;
            _tos_cache2 = self;
            _tos_cache1 = attr;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_WITH_VALUES_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            owner = _stack_item_0;
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            assert((oparg & 1) == 0);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(owner);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            attr = PyStackRef_FromPyObjectNew(descr);
            _tos_cache0 = attr;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_NO_DICT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            owner = _stack_item_0;
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            assert((oparg & 1) == 0);
            assert(PyStackRef_TYPE(owner)->tp_dictoffset == 0);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(owner);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            attr = PyStackRef_FromPyObjectNew(descr);
            _tos_cache0 = attr;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_ATTR_METHOD_LAZY_DICT_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            owner = _stack_item_0;
            uint16_t dictoffset = (uint16_t)CURRENT_OPERAND0();
            char *ptr = ((char *)PyStackRef_AsPyObjectBorrowNonInt(owner)) + MANAGED_DICT_OFFSET + dictoffset;
            PyObject *dict = FT_ATOMIC_LOAD_PTR_ACQUIRE(*(PyObject **)ptr);
            if (dict != NULL) {
                stack_pointer[0] = owner;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = owner;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_ATTR_METHOD_LAZY_DICT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            owner = stack_pointer[-1];
            uint16_t dictoffset = (uint16_t)CURRENT_OPERAND0();
            char *ptr = ((char *)PyStackRef_AsPyObjectBorrowNonInt(owner)) + MANAGED_DICT_OFFSET + dictoffset;
            PyObject *dict = FT_ATOMIC_LOAD_PTR_ACQUIRE(*(PyObject **)ptr);
            if (dict != NULL) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_ATTR_METHOD_LAZY_DICT_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            owner = _stack_item_1;
            uint16_t dictoffset = (uint16_t)CURRENT_OPERAND0();
            char *ptr = ((char *)PyStackRef_AsPyObjectBorrowNonInt(owner)) + MANAGED_DICT_OFFSET + dictoffset;
            PyObject *dict = FT_ATOMIC_LOAD_PTR_ACQUIRE(*(PyObject **)ptr);
            if (dict != NULL) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = owner;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = owner;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _CHECK_ATTR_METHOD_LAZY_DICT_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef owner;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            owner = _stack_item_2;
            uint16_t dictoffset = (uint16_t)CURRENT_OPERAND0();
            char *ptr = ((char *)PyStackRef_AsPyObjectBorrowNonInt(owner)) + MANAGED_DICT_OFFSET + dictoffset;
            PyObject *dict = FT_ATOMIC_LOAD_PTR_ACQUIRE(*(PyObject **)ptr);
            if (dict != NULL) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = owner;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = owner;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_ATTR_METHOD_LAZY_DICT_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef self;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            owner = _stack_item_0;
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            assert(oparg & 1);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            attr = PyStackRef_FromPyObjectNew(descr);
            self = owner;
            _tos_cache1 = self;
            _tos_cache0 = attr;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_ATTR_METHOD_LAZY_DICT_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef self;
            oparg = CURRENT_OPARG();
            owner = stack_pointer[-1];
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            assert(oparg & 1);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            attr = PyStackRef_FromPyObjectNew(descr);
            self = owner;
            _tos_cache0 = self;
            stack_pointer[-1] = attr;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_ATTR_METHOD_LAZY_DICT_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef owner;
            _PyStackRef attr;
            _PyStackRef self;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            owner = _stack_item_1;
            PyObject *descr = (PyObject *)CURRENT_OPERAND0();
            assert(oparg & 1);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            attr = PyStackRef_FromPyObjectNew(descr);
            self = owner;
            _tos_cache2 = self;
            _tos_cache1 = attr;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _MAYBE_EXPAND_METHOD_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef self_or_null;
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            if (PyStackRef_TYPE(callable) == &PyMethod_Type && PyStackRef_IsNull(self_or_null)) {
                PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
                PyObject *self = ((PyMethodObject *)callable_o)->im_self;
                self_or_null = PyStackRef_FromPyObjectNew(self);
                PyObject *method = ((PyMethodObject *)callable_o)->im_func;
                _PyStackRef temp = callable;
                callable = PyStackRef_FromPyObjectNew(method);
                stack_pointer[-2 - oparg] = callable;
                stack_pointer[-1 - oparg] = self_or_null;
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(temp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            stack_pointer[-2 - oparg] = callable;
            stack_pointer[-1 - oparg] = self_or_null;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        /* _DO_CALL is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        /* _MONITOR_CALL is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _PY_FRAME_GENERAL_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef new_frame;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            int total_args = oparg;
            if (!PyStackRef_IsNull(self_or_null)) {
                args--;
                total_args++;
            }
            assert(Py_TYPE(callable_o) == &PyFunction_Type);
            int code_flags = ((PyCodeObject*)PyFunction_GET_CODE(callable_o))->co_flags;
            PyObject *locals = code_flags & CO_OPTIMIZED ? NULL : Py_NewRef(PyFunction_GET_GLOBALS(callable_o));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyInterpreterFrame *temp = _PyEvalFramePushAndInit(
                tstate, callable, locals,
                args, total_args, NULL, frame
            );
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (temp == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            new_frame = PyStackRef_Wrap(temp);
            _tos_cache0 = new_frame;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_FUNCTION_VERSION_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            callable = stack_pointer[-2 - oparg];
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            if (!PyStackRef_FunctionCheck(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            PyFunctionObject *func = (PyFunctionObject *)callable_o;
            if (func->func_version != func_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_FUNCTION_VERSION_INLINE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            PyObject *callable_o = (PyObject *)CURRENT_OPERAND1();
            assert(PyFunction_Check(callable_o));
            PyFunctionObject *func = (PyFunctionObject *)callable_o;
            if (func->func_version != func_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_FUNCTION_VERSION_INLINE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            PyObject *callable_o = (PyObject *)CURRENT_OPERAND1();
            assert(PyFunction_Check(callable_o));
            PyFunctionObject *func = (PyFunctionObject *)callable_o;
            if (func->func_version != func_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_FUNCTION_VERSION_INLINE_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            PyObject *callable_o = (PyObject *)CURRENT_OPERAND1();
            assert(PyFunction_Check(callable_o));
            PyFunctionObject *func = (PyFunctionObject *)callable_o;
            if (func->func_version != func_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _CHECK_FUNCTION_VERSION_INLINE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            PyObject *callable_o = (PyObject *)CURRENT_OPERAND1();
            assert(PyFunction_Check(callable_o));
            PyFunctionObject *func = (PyFunctionObject *)callable_o;
            if (func->func_version != func_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CHECK_METHOD_VERSION_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef null;
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            if (!PyStackRef_MethodCheck(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            PyObject *func = ((PyMethodObject *)callable_o)->im_func;
            if (!PyFunction_Check(func)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (((PyFunctionObject *)func)->func_version != func_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyStackRef_IsNull(null)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _EXPAND_METHOD_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef self_or_null;
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            assert(PyStackRef_IsNull(self_or_null));
            assert(Py_TYPE(callable_o) == &PyMethod_Type);
            self_or_null = PyStackRef_FromPyObjectNew(((PyMethodObject *)callable_o)->im_self);
            _PyStackRef temp = callable;
            callable = PyStackRef_FromPyObjectNew(((PyMethodObject *)callable_o)->im_func);
            assert(PyStackRef_FunctionCheck(callable));
            stack_pointer[-2 - oparg] = callable;
            stack_pointer[-1 - oparg] = self_or_null;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(temp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_IS_NOT_PY_CALLABLE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            callable = stack_pointer[-2 - oparg];
            if (PyStackRef_IsTaggedInt(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            if (PyFunction_Check(callable_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (Py_TYPE(callable_o) == &PyMethod_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CALL_NON_PY_GENERAL_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            #if TIER_ONE
            assert(opcode != INSTRUMENTED_CALL);
            #endif
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            int total_args = oparg;
            _PyStackRef *arguments = args;
            if (!PyStackRef_IsNull(self_or_null)) {
                arguments--;
                total_args++;
            }
            STACKREFS_TO_PYOBJECTS(arguments, total_args, args_o);
            if (CONVERSION_FAILED(args_o)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp;
                for (int _i = oparg; --_i >= 0;) {
                    tmp = args[_i];
                    args[_i] = PyStackRef_NULL;
                    PyStackRef_CLOSE(tmp);
                }
                tmp = self_or_null;
                self_or_null = PyStackRef_NULL;
                stack_pointer[-1 - oparg] = self_or_null;
                PyStackRef_XCLOSE(tmp);
                tmp = callable;
                callable = PyStackRef_NULL;
                stack_pointer[-2 - oparg] = callable;
                PyStackRef_CLOSE(tmp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -2 - oparg;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = PyObject_Vectorcall(
                callable_o, args_o,
                total_args | PY_VECTORCALL_ARGUMENTS_OFFSET,
                NULL);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            STACKREFS_TO_PYOBJECTS_CLEANUP(args_o);
            assert((res_o != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp;
            for (int _i = oparg; --_i >= 0;) {
                tmp = args[_i];
                args[_i] = PyStackRef_NULL;
                PyStackRef_CLOSE(tmp);
            }
            tmp = self_or_null;
            self_or_null = PyStackRef_NULL;
            stack_pointer[-1 - oparg] = self_or_null;
            PyStackRef_XCLOSE(tmp);
            tmp = callable;
            callable = PyStackRef_NULL;
            stack_pointer[-2 - oparg] = callable;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_CALL_BOUND_METHOD_EXACT_ARGS_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef null;
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            if (!PyStackRef_IsNull(null)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyStackRef_MethodCheck(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _INIT_CALL_BOUND_METHOD_EXACT_ARGS_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef self_or_null;
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            assert(PyStackRef_IsNull(self_or_null));
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            STAT_INC(CALL, hit);
            self_or_null = PyStackRef_FromPyObjectNew(((PyMethodObject *)callable_o)->im_self);
            _PyStackRef temp = callable;
            callable = PyStackRef_FromPyObjectNew(((PyMethodObject *)callable_o)->im_func);
            stack_pointer[-2 - oparg] = callable;
            stack_pointer[-1 - oparg] = self_or_null;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(temp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_PEP_523_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            if (tstate->interp->eval_frame) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_PEP_523_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            if (tstate->interp->eval_frame) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_PEP_523_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            if (tstate->interp->eval_frame) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _CHECK_PEP_523_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            if (tstate->interp->eval_frame) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CHECK_FUNCTION_EXACT_ARGS_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef self_or_null;
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            assert(PyFunction_Check(callable_o));
            PyFunctionObject *func = (PyFunctionObject *)callable_o;
            PyCodeObject *code = (PyCodeObject *)func->func_code;
            if (code->co_argcount != oparg + (!PyStackRef_IsNull(self_or_null))) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_STACK_SPACE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            callable = stack_pointer[-2 - oparg];
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            PyFunctionObject *func = (PyFunctionObject *)callable_o;
            PyCodeObject *code = (PyCodeObject *)func->func_code;
            if (!_PyThreadState_HasStackSpace(tstate, code->co_framesize)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_RECURSION_REMAINING_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            if (tstate->py_recursion_remaining <= 1) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_RECURSION_REMAINING_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            if (tstate->py_recursion_remaining <= 1) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_RECURSION_REMAINING_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            if (tstate->py_recursion_remaining <= 1) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _CHECK_RECURSION_REMAINING_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            if (tstate->py_recursion_remaining <= 1) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS_0_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef new_frame;
            oparg = 0;
            assert(oparg == CURRENT_OPARG());
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int has_self = !PyStackRef_IsNull(self_or_null);
            STAT_INC(CALL, hit);
            _PyInterpreterFrame *pushed_frame = _PyFrame_PushUnchecked(tstate, callable, oparg + has_self, frame);
            _PyStackRef *first_non_self_local = pushed_frame->localsplus + has_self;
            pushed_frame->localsplus[0] = self_or_null;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            new_frame = PyStackRef_Wrap(pushed_frame);
            _tos_cache0 = new_frame;
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS_1_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef new_frame;
            oparg = 1;
            assert(oparg == CURRENT_OPARG());
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int has_self = !PyStackRef_IsNull(self_or_null);
            STAT_INC(CALL, hit);
            _PyInterpreterFrame *pushed_frame = _PyFrame_PushUnchecked(tstate, callable, oparg + has_self, frame);
            _PyStackRef *first_non_self_local = pushed_frame->localsplus + has_self;
            pushed_frame->localsplus[0] = self_or_null;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            new_frame = PyStackRef_Wrap(pushed_frame);
            _tos_cache0 = new_frame;
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS_2_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef new_frame;
            oparg = 2;
            assert(oparg == CURRENT_OPARG());
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int has_self = !PyStackRef_IsNull(self_or_null);
            STAT_INC(CALL, hit);
            _PyInterpreterFrame *pushed_frame = _PyFrame_PushUnchecked(tstate, callable, oparg + has_self, frame);
            _PyStackRef *first_non_self_local = pushed_frame->localsplus + has_self;
            pushed_frame->localsplus[0] = self_or_null;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            new_frame = PyStackRef_Wrap(pushed_frame);
            _tos_cache0 = new_frame;
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS_3_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef new_frame;
            oparg = 3;
            assert(oparg == CURRENT_OPARG());
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int has_self = !PyStackRef_IsNull(self_or_null);
            STAT_INC(CALL, hit);
            _PyInterpreterFrame *pushed_frame = _PyFrame_PushUnchecked(tstate, callable, oparg + has_self, frame);
            _PyStackRef *first_non_self_local = pushed_frame->localsplus + has_self;
            pushed_frame->localsplus[0] = self_or_null;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            new_frame = PyStackRef_Wrap(pushed_frame);
            _tos_cache0 = new_frame;
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS_4_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef new_frame;
            oparg = 4;
            assert(oparg == CURRENT_OPARG());
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int has_self = !PyStackRef_IsNull(self_or_null);
            STAT_INC(CALL, hit);
            _PyInterpreterFrame *pushed_frame = _PyFrame_PushUnchecked(tstate, callable, oparg + has_self, frame);
            _PyStackRef *first_non_self_local = pushed_frame->localsplus + has_self;
            pushed_frame->localsplus[0] = self_or_null;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            new_frame = PyStackRef_Wrap(pushed_frame);
            _tos_cache0 = new_frame;
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef new_frame;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int has_self = !PyStackRef_IsNull(self_or_null);
            STAT_INC(CALL, hit);
            _PyInterpreterFrame *pushed_frame = _PyFrame_PushUnchecked(tstate, callable, oparg + has_self, frame);
            _PyStackRef *first_non_self_local = pushed_frame->localsplus + has_self;
            pushed_frame->localsplus[0] = self_or_null;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            new_frame = PyStackRef_Wrap(pushed_frame);
            _tos_cache0 = new_frame;
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _PUSH_FRAME_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef new_frame;
            _PyStackRef _stack_item_0 = _tos_cache0;
            new_frame = _stack_item_0;
            assert(tstate->interp->eval_frame == NULL);
            _PyInterpreterFrame *temp = PyStackRef_Unwrap(new_frame);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            assert(temp->previous == frame || temp->previous->previous == frame);
            CALL_STAT_INC(inlined_py_calls);
            frame = tstate->current_frame = temp;
            tstate->py_recursion_remaining--;
            LOAD_SP();
            LOAD_IP(0);
            LLTRACE_RESUME_FRAME();
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOS_NULL_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef null;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            null = _stack_item_0;
            if (!PyStackRef_IsNull(null)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = null;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOS_NULL_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef null;
            null = stack_pointer[-2];
            if (!PyStackRef_IsNull(null)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOS_NULL_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef null;
            _PyStackRef _stack_item_0 = _tos_cache0;
            null = stack_pointer[-1];
            if (!PyStackRef_IsNull(null)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOS_NULL_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef null;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            null = _stack_item_1;
            if (!PyStackRef_IsNull(null)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = null;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_NOS_NOT_NULL_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            nos = _stack_item_0;
            if (PyStackRef_IsNull(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(2);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = nos;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _GUARD_NOS_NOT_NULL_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef nos;
            nos = stack_pointer[-2];
            if (PyStackRef_IsNull(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_NOS_NOT_NULL_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            nos = stack_pointer[-1];
            if (PyStackRef_IsNull(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_NOS_NOT_NULL_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef nos;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            nos = _stack_item_1;
            if (PyStackRef_IsNull(nos)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = nos;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_THIRD_NULL_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef null;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            null = _stack_item_0;
            if (!PyStackRef_IsNull(null)) {
                stack_pointer[0] = null;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = null;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _GUARD_CALLABLE_TYPE_1_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            callable = _stack_item_0;
            if (!PyStackRef_IsNonIntObject(callable, (PyObject *)&PyType_Type)) {
                stack_pointer[0] = callable;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = callable;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CALL_TYPE_1_r31: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef arg;
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef res;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            oparg = CURRENT_OPARG();
            arg = _stack_item_2;
            null = _stack_item_1;
            callable = _stack_item_0;
            assert(oparg == 1);
            (void)callable;
            (void)null;
            STAT_INC(CALL, hit);
            res = PyStackRef_FromPyObjectNew(PyStackRef_TYPE(arg));
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(arg);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _tos_cache0 = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_CALLABLE_STR_1_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            callable = _stack_item_0;
            if (!PyStackRef_IsNonIntObject(callable, (PyObject *)&PyUnicode_Type)) {
                stack_pointer[0] = callable;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = callable;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CALL_STR_1_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef arg;
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            arg = stack_pointer[-1];
            null = stack_pointer[-2];
            callable = stack_pointer[-3];
            PyObject *arg_o = PyStackRef_AsPyObjectBorrowed(&arg);
            assert(oparg == 1);
            STAT_INC(CALL, hit);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = PyObject_Str(arg_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            (void)callable;
            (void)null;
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(arg);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_CALLABLE_TUPLE_1_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            callable = _stack_item_0;
            if (!PyStackRef_IsNonIntObject(callable, (PyObject *)&PyTuple_Type)) {
                stack_pointer[0] = callable;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = callable;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CALL_TUPLE_1_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef arg;
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            arg = stack_pointer[-1];
            null = stack_pointer[-2];
            callable = stack_pointer[-3];
            (void)callable;
            (void)null;
            assert(oparg == 1);
            STAT_INC(CALL, hit);
            PyObject *res_o;
            if (PyStackRef_IsTaggedInt(arg)) {
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyErr_SetString(tstate, PyExc_TypeError, "'int' object is not iterable");
                stack_pointer = _PyFrame_GetStackPointer(frame);
                res_o = NULL;
            }
            else {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                res_o = PySequence_Tuple(PyStackRef_AsPyObjectBorrowNonInt(arg));
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(arg);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            if (res_o == NULL) {
                stack_pointer += -2;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_AND_ALLOCATE_OBJECT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef self_or_null;
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            uint32_t type_version = (uint32_t)CURRENT_OPERAND0();
            if (!PyStackRef_IsNull(self_or_null)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyStackRef_TypeCheck(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            PyTypeObject *tp = (PyTypeObject *)callable_o;
            if (FT_ATOMIC_LOAD_UINT32_RELAXED(tp->tp_version_tag) != type_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(tp->tp_new == PyBaseObject_Type.tp_new);
            assert(tp->tp_flags & Py_TPFLAGS_HEAPTYPE);
            assert(tp->tp_alloc == PyType_GenericAlloc);
            PyHeapTypeObject *cls = (PyHeapTypeObject *)callable_o;
            PyFunctionObject *init_func = (PyFunctionObject *)FT_ATOMIC_LOAD_PTR_ACQUIRE(cls->_spec_cache.init);
            PyCodeObject *code = (PyCodeObject *)init_func->func_code;
            if (!_PyThreadState_HasStackSpace(tstate, code->co_framesize + _Py_InitCleanup.co_framesize)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *self_o = PyType_GenericAlloc(tp, 0);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (self_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            self_or_null = PyStackRef_FromPyObjectStealNonInt(self_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _PyStackRef temp = callable;
            callable = PyStackRef_FromPyObjectNew(init_func);
            stack_pointer[-2 - oparg] = callable;
            stack_pointer[-1 - oparg] = self_or_null;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(temp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CREATE_INIT_FRAME_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self;
            _PyStackRef init;
            _PyStackRef init_frame;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self = stack_pointer[-1 - oparg];
            init = stack_pointer[-2 - oparg];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyInterpreterFrame *shim = _PyFrame_PushTrampolineUnchecked(
                tstate, (PyCodeObject *)&_Py_InitCleanup, 1, frame);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            assert(_PyFrame_GetBytecode(shim)[0].op.code == EXIT_INIT_CHECK);
            assert(_PyFrame_GetBytecode(shim)[1].op.code == RETURN_VALUE);
            shim->localsplus[0] = PyStackRef_DUP(self);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyInterpreterFrame *temp = _PyEvalFramePushAndInit(
                tstate, init, NULL, args-1, oparg+1, NULL, shim);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (temp == NULL) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyEval_FrameClearAndPop(tstate, shim);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            frame->return_offset = 1 + INLINE_CACHE_ENTRIES_CALL;
            tstate->py_recursion_remaining--;
            init_frame = PyStackRef_Wrap(temp);
            _tos_cache0 = init_frame;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _EXIT_INIT_CHECK_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef should_be_none;
            should_be_none = stack_pointer[-1];
            if (!PyStackRef_IsNone(should_be_none)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyErr_Format(PyExc_TypeError,
                             "__init__() should return None, not '%.200s'",
                             Py_TYPE(PyStackRef_TYPE(should_be_none)->tp_name));
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CALL_BUILTIN_CLASS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            if (!PyStackRef_TypeCheck(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            PyTypeObject *tp = (PyTypeObject *)callable_o;
            int total_args = oparg;
            _PyStackRef *arguments = args;
            if (!PyStackRef_IsNull(self_or_null)) {
                arguments--;
                total_args++;
            }
            if (tp->tp_vectorcall == NULL) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            STACKREFS_TO_PYOBJECTS(arguments, total_args, args_o);
            if (CONVERSION_FAILED(args_o)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp;
                for (int _i = oparg; --_i >= 0;) {
                    tmp = args[_i];
                    args[_i] = PyStackRef_NULL;
                    PyStackRef_CLOSE(tmp);
                }
                tmp = self_or_null;
                self_or_null = PyStackRef_NULL;
                stack_pointer[-1 - oparg] = self_or_null;
                PyStackRef_XCLOSE(tmp);
                tmp = callable;
                callable = PyStackRef_NULL;
                stack_pointer[-2 - oparg] = callable;
                PyStackRef_CLOSE(tmp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -2 - oparg;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = tp->tp_vectorcall((PyObject *)tp, args_o, total_args, NULL);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            STACKREFS_TO_PYOBJECTS_CLEANUP(args_o);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp;
            for (int _i = oparg; --_i >= 0;) {
                tmp = args[_i];
                args[_i] = PyStackRef_NULL;
                PyStackRef_CLOSE(tmp);
            }
            tmp = self_or_null;
            self_or_null = PyStackRef_NULL;
            stack_pointer[-1 - oparg] = self_or_null;
            PyStackRef_XCLOSE(tmp);
            tmp = callable;
            callable = PyStackRef_NULL;
            stack_pointer[-2 - oparg] = callable;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CALL_BUILTIN_O_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int total_args = oparg;
            if (!PyStackRef_IsNull(self_or_null)) {
                args--;
                total_args++;
            }
            if (total_args != 1) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyStackRef_CFunctionCheckExact(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            if (PyCFunction_GET_FLAGS(callable_o) != METH_O) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (_Py_ReachedRecursionLimit(tstate)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            PyCFunction cfunc = PyCFunction_GET_FUNCTION(callable_o);
            _PyStackRef arg = args[0];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = _PyCFunction_TrampolineCall(cfunc, PyCFunction_GET_SELF(callable_o), PyStackRef_AsPyObjectBorrowed(&arg));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _Py_LeaveRecursiveCallTstate(tstate);
            assert((res_o != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(arg);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CALL_BUILTIN_FAST_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int total_args = oparg;
            _PyStackRef *arguments = args;
            if (!PyStackRef_IsNull(self_or_null)) {
                arguments--;
                total_args++;
            }
            if (!PyStackRef_CFunctionCheckExact(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            if (PyCFunction_GET_FLAGS(callable_o) != METH_FASTCALL) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            PyCFunction cfunc = PyCFunction_GET_FUNCTION(callable_o);
            STACKREFS_TO_PYOBJECTS(arguments, total_args, args_o);
            if (CONVERSION_FAILED(args_o)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp;
                for (int _i = oparg; --_i >= 0;) {
                    tmp = args[_i];
                    args[_i] = PyStackRef_NULL;
                    PyStackRef_CLOSE(tmp);
                }
                tmp = self_or_null;
                self_or_null = PyStackRef_NULL;
                stack_pointer[-1 - oparg] = self_or_null;
                PyStackRef_XCLOSE(tmp);
                tmp = callable;
                callable = PyStackRef_NULL;
                stack_pointer[-2 - oparg] = callable;
                PyStackRef_CLOSE(tmp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -2 - oparg;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = _PyCFunctionFast_CAST(cfunc)(
                PyCFunction_GET_SELF(callable_o),
                args_o,
                total_args);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            STACKREFS_TO_PYOBJECTS_CLEANUP(args_o);
            assert((res_o != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp;
            for (int _i = oparg; --_i >= 0;) {
                tmp = args[_i];
                args[_i] = PyStackRef_NULL;
                PyStackRef_CLOSE(tmp);
            }
            tmp = self_or_null;
            self_or_null = PyStackRef_NULL;
            stack_pointer[-1 - oparg] = self_or_null;
            PyStackRef_XCLOSE(tmp);
            tmp = callable;
            callable = PyStackRef_NULL;
            stack_pointer[-2 - oparg] = callable;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CALL_BUILTIN_FAST_WITH_KEYWORDS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int total_args = oparg;
            _PyStackRef *arguments = args;
            if (!PyStackRef_IsNull(self_or_null)) {
                arguments--;
                total_args++;
            }
            if (!PyStackRef_CFunctionCheckExact(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            if (PyCFunction_GET_FLAGS(callable_o) != (METH_FASTCALL | METH_KEYWORDS)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyCFunctionFastWithKeywords cfunc =
            _PyCFunctionFastWithKeywords_CAST(PyCFunction_GET_FUNCTION(callable_o));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            STACKREFS_TO_PYOBJECTS(arguments, total_args, args_o);
            if (CONVERSION_FAILED(args_o)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp;
                for (int _i = oparg; --_i >= 0;) {
                    tmp = args[_i];
                    args[_i] = PyStackRef_NULL;
                    PyStackRef_CLOSE(tmp);
                }
                tmp = self_or_null;
                self_or_null = PyStackRef_NULL;
                stack_pointer[-1 - oparg] = self_or_null;
                PyStackRef_XCLOSE(tmp);
                tmp = callable;
                callable = PyStackRef_NULL;
                stack_pointer[-2 - oparg] = callable;
                PyStackRef_CLOSE(tmp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -2 - oparg;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = cfunc(PyCFunction_GET_SELF(callable_o), args_o, total_args, NULL);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            STACKREFS_TO_PYOBJECTS_CLEANUP(args_o);
            assert((res_o != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp;
            for (int _i = oparg; --_i >= 0;) {
                tmp = args[_i];
                args[_i] = PyStackRef_NULL;
                PyStackRef_CLOSE(tmp);
            }
            tmp = self_or_null;
            self_or_null = PyStackRef_NULL;
            stack_pointer[-1 - oparg] = self_or_null;
            PyStackRef_XCLOSE(tmp);
            tmp = callable;
            callable = PyStackRef_NULL;
            stack_pointer[-2 - oparg] = callable;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_CALLABLE_LEN_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            callable = _stack_item_0;
            PyInterpreterState *interp = tstate->interp;
            if (!PyStackRef_IsNonIntObject(callable, interp->callable_cache.len)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = callable;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CALL_LEN_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef arg;
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef res;
            arg = stack_pointer[-1];
            null = stack_pointer[-2];
            callable = stack_pointer[-3];
            (void)null;
            STAT_INC(CALL, hit);
            if (PyStackRef_IsTaggedInt(callable)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyErr_SetString(tstate, PyExc_TypeError, "object of type 'int' has no len()");
                stack_pointer = _PyFrame_GetStackPointer(frame);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            PyObject *arg_o = PyStackRef_AsPyObjectBorrowed(&arg);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            Py_ssize_t len_i = PyObject_Length(arg_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (len_i < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            PyObject *res_o = PyLong_FromSsize_t(len_i);
            assert((res_o != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(arg);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_CALLABLE_ISINSTANCE_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            callable = stack_pointer[-1];
            PyInterpreterState *interp = tstate->interp;
            if (!PyStackRef_IsNonIntObject(callable, interp->callable_cache.isinstance)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CALL_ISINSTANCE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef cls;
            _PyStackRef instance;
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef res;
            cls = stack_pointer[-1];
            instance = stack_pointer[-2];
            null = stack_pointer[-3];
            callable = stack_pointer[-4];
            STAT_INC(CALL, hit);
            PyObject *cls_o = PyStackRef_AsPyObjectBorrowed(&cls);
            PyObject *inst_o;
            if (PyStackRef_IsTaggedInt(instance)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                inst_o = _PyLong_GetZero();
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            else {
                inst_o = PyStackRef_AsPyObjectBorrowNonInt(instance);
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            int retval = PyObject_IsInstance(inst_o, cls_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (retval < 0) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(cls);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(instance);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            (void)null;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            res = retval ? PyStackRef_True : PyStackRef_False;
            assert((!PyStackRef_IsNull(res)) ^ (_PyErr_Occurred(tstate) != NULL));
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _GUARD_CALLABLE_LIST_APPEND_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            callable = _stack_item_0;
            PyInterpreterState *interp = tstate->interp;
            if (!PyStackRef_IsNonIntObject(callable, interp->callable_cache.list_append)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(3);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = callable;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CALL_LIST_APPEND_r30: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef arg;
            _PyStackRef self;
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            oparg = CURRENT_OPARG();
            arg = _stack_item_2;
            self = _stack_item_1;
            callable = _stack_item_0;
            assert(oparg == 1);
            if (!PyStackRef_ListCheckExact(self)) {
                stack_pointer[0] = callable;
                stack_pointer[1] = self;
                stack_pointer[2] = arg;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *self_o = PyStackRef_AsPyObjectBorrowNonInt(self);
            if (!LOCK_OBJECT(self_o)) {
                stack_pointer[0] = callable;
                stack_pointer[1] = self;
                stack_pointer[2] = arg;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            int err = _PyList_AppendTakeRef((PyListObject *)self_o, PyStackRef_AsPyObjectSteal(arg));
            UNLOCK_OBJECT(self_o);
            stack_pointer[0] = callable;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(self);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (err) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            #if TIER_ONE

            assert(next_instr->op.code == POP_TOP);
            SKIP_OVER(1);
            #endif
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_O_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int total_args = oparg;
            _PyStackRef *arguments = args;
            if (!PyStackRef_IsNull(self_or_null)) {
                arguments--;
                total_args++;
            }
            if (PyStackRef_TYPE(callable) != &PyMethodDescr_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            PyMethodDescrObject *method = (PyMethodDescrObject *)callable_o;
            if (total_args != 2) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyMethodDef *meth = method->d_method;
            if (meth->ml_flags != METH_O) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (_Py_ReachedRecursionLimit(tstate)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyStackRef_TYPE(arguments[0]) != method->d_common.d_type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            PyCFunction cfunc = meth->ml_meth;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = _PyCFunction_TrampolineCall(cfunc,
                PyStackRef_AsPyObjectBorrowed(&arguments[0]),
                PyStackRef_AsPyObjectBorrowed(&arguments[1]));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _Py_LeaveRecursiveCallTstate(tstate);
            assert((res_o != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp;
            for (int _i = oparg; --_i >= 0;) {
                tmp = args[_i];
                args[_i] = PyStackRef_NULL;
                PyStackRef_CLOSE(tmp);
            }
            tmp = self_or_null;
            self_or_null = PyStackRef_NULL;
            stack_pointer[-1 - oparg] = self_or_null;
            PyStackRef_XCLOSE(tmp);
            tmp = callable;
            callable = PyStackRef_NULL;
            stack_pointer[-2 - oparg] = callable;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            if (PyStackRef_TYPE(callable) != &PyMethodDescr_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            int total_args = oparg;
            _PyStackRef *arguments = args;
            if (!PyStackRef_IsNull(self_or_null)) {
                arguments--;
                total_args++;
            }
            if (total_args == 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyMethodDescrObject *method = (PyMethodDescrObject *)callable_o;
            PyMethodDef *meth = method->d_method;
            if (meth->ml_flags != (METH_FASTCALL|METH_KEYWORDS)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyTypeObject *d_type = method->d_common.d_type;
            PyObject *self = PyStackRef_AsPyObjectBorrowed(&arguments[0]);
            assert(self != NULL);
            if (!Py_IS_TYPE(self, d_type)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            int nargs = total_args - 1;
            STACKREFS_TO_PYOBJECTS(arguments, total_args, args_o);
            if (CONVERSION_FAILED(args_o)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp;
                for (int _i = oparg; --_i >= 0;) {
                    tmp = args[_i];
                    args[_i] = PyStackRef_NULL;
                    PyStackRef_CLOSE(tmp);
                }
                tmp = self_or_null;
                self_or_null = PyStackRef_NULL;
                stack_pointer[-1 - oparg] = self_or_null;
                PyStackRef_XCLOSE(tmp);
                tmp = callable;
                callable = PyStackRef_NULL;
                stack_pointer[-2 - oparg] = callable;
                PyStackRef_CLOSE(tmp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -2 - oparg;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyCFunctionFastWithKeywords cfunc =
            _PyCFunctionFastWithKeywords_CAST(meth->ml_meth);
            PyObject *res_o = cfunc(self, (args_o + 1), nargs, NULL);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            STACKREFS_TO_PYOBJECTS_CLEANUP(args_o);
            assert((res_o != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp;
            for (int _i = oparg; --_i >= 0;) {
                tmp = args[_i];
                args[_i] = PyStackRef_NULL;
                PyStackRef_CLOSE(tmp);
            }
            tmp = self_or_null;
            self_or_null = PyStackRef_NULL;
            stack_pointer[-1 - oparg] = self_or_null;
            PyStackRef_XCLOSE(tmp);
            tmp = callable;
            callable = PyStackRef_NULL;
            stack_pointer[-2 - oparg] = callable;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_NOARGS_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            assert(oparg == 0 || oparg == 1);
            int total_args = oparg;
            if (!PyStackRef_IsNull(self_or_null)) {
                args--;
                total_args++;
            }
            if (total_args != 1) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyStackRef_TYPE(callable) != &PyMethodDescr_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            PyMethodDescrObject *method = (PyMethodDescrObject *)callable_o;
            PyMethodDef *meth = method->d_method;
            if (PyStackRef_TYPE(args[0]) != method->d_common.d_type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *self = PyStackRef_AsPyObjectBorrowed(&args[0]);
            if (meth->ml_flags != METH_NOARGS) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (_Py_ReachedRecursionLimit(tstate)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            PyCFunction cfunc = meth->ml_meth;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = _PyCFunction_TrampolineCall(cfunc, self, NULL);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            _Py_LeaveRecursiveCallTstate(tstate);
            assert((res_o != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            stack_pointer += -oparg;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(args[0]);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int total_args = oparg;
            _PyStackRef *arguments = args;
            if (!PyStackRef_IsNull(self_or_null)) {
                arguments--;
                total_args++;
            }
            if (total_args == 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyStackRef_TYPE(callable) != &PyMethodDescr_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            PyMethodDescrObject *method = (PyMethodDescrObject *)callable_o;
            PyMethodDef *meth = method->d_method;
            if (meth->ml_flags != METH_FASTCALL) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *self = PyStackRef_AsPyObjectBorrowed(&arguments[0]);
            assert(self != NULL);
            if (!Py_IS_TYPE(self, method->d_common.d_type)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            int nargs = total_args - 1;
            STACKREFS_TO_PYOBJECTS(arguments, total_args, args_o);
            if (CONVERSION_FAILED(args_o)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp;
                for (int _i = oparg; --_i >= 0;) {
                    tmp = args[_i];
                    args[_i] = PyStackRef_NULL;
                    PyStackRef_CLOSE(tmp);
                }
                tmp = self_or_null;
                self_or_null = PyStackRef_NULL;
                stack_pointer[-1 - oparg] = self_or_null;
                PyStackRef_XCLOSE(tmp);
                tmp = callable;
                callable = PyStackRef_NULL;
                stack_pointer[-2 - oparg] = callable;
                PyStackRef_CLOSE(tmp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -2 - oparg;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyCFunctionFast cfunc = _PyCFunctionFast_CAST(meth->ml_meth);
            PyObject *res_o = cfunc(self, (args_o + 1), nargs);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            STACKREFS_TO_PYOBJECTS_CLEANUP(args_o);
            assert((res_o != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp;
            for (int _i = oparg; --_i >= 0;) {
                tmp = args[_i];
                args[_i] = PyStackRef_NULL;
                PyStackRef_CLOSE(tmp);
            }
            tmp = self_or_null;
            self_or_null = PyStackRef_NULL;
            stack_pointer[-1 - oparg] = self_or_null;
            PyStackRef_XCLOSE(tmp);
            tmp = callable;
            callable = PyStackRef_NULL;
            stack_pointer[-2 - oparg] = callable;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        /* _MONITOR_CALL_KW is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _MAYBE_EXPAND_METHOD_KW_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef self_or_null;
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            self_or_null = stack_pointer[-2 - oparg];
            callable = stack_pointer[-3 - oparg];
            if (PyStackRef_TYPE(callable) == &PyMethod_Type && PyStackRef_IsNull(self_or_null)) {
                PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
                PyObject *self = ((PyMethodObject *)callable_o)->im_self;
                self_or_null = PyStackRef_FromPyObjectNew(self);
                PyObject *method = ((PyMethodObject *)callable_o)->im_func;
                _PyStackRef temp = callable;
                callable = PyStackRef_FromPyObjectNew(method);
                stack_pointer[-3 - oparg] = callable;
                stack_pointer[-2 - oparg] = self_or_null;
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(temp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            stack_pointer[-3 - oparg] = callable;
            stack_pointer[-2 - oparg] = self_or_null;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        /* _DO_CALL_KW is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _PY_FRAME_KW_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef kwnames;
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef new_frame;
            oparg = CURRENT_OPARG();
            kwnames = stack_pointer[-1];
            args = &stack_pointer[-1 - oparg];
            self_or_null = stack_pointer[-2 - oparg];
            callable = stack_pointer[-3 - oparg];
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            int total_args = oparg;
            _PyStackRef *arguments = args;
            if (!PyStackRef_IsNull(self_or_null)) {
                arguments--;
                total_args++;
            }
            PyObject *kwnames_o = PyStackRef_AsPyObjectBorrowNonInt(kwnames);
            int positional_args = total_args - (int)PyTuple_GET_SIZE(kwnames_o);
            assert(Py_TYPE(callable_o) == &PyFunction_Type);
            int code_flags = ((PyCodeObject*)PyFunction_GET_CODE(callable_o))->co_flags;
            PyObject *locals = code_flags & CO_OPTIMIZED ? NULL : Py_NewRef(PyFunction_GET_GLOBALS(callable_o));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyInterpreterFrame *temp = _PyEvalFramePushAndInit(
                tstate, callable, locals,
                arguments, positional_args, kwnames_o, frame
            );
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(kwnames);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (temp == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            new_frame = PyStackRef_Wrap(temp);
            _tos_cache0 = new_frame;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_FUNCTION_VERSION_KW_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            callable = stack_pointer[-2 - oparg];
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            if (!PyStackRef_FunctionCheck(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            PyFunctionObject *func = (PyFunctionObject *)callable_o;
            if (func->func_version != func_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_METHOD_VERSION_KW_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            if (!PyStackRef_MethodCheck(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            PyObject *func = ((PyMethodObject *)callable_o)->im_func;
            if (!PyFunction_Check(func)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            if (((PyFunctionObject *)func)->func_version != func_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyStackRef_IsNull(null)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _EXPAND_METHOD_KW_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef self_or_null;
            _PyStackRef callable;
            oparg = CURRENT_OPARG();
            self_or_null = stack_pointer[-2 - oparg];
            callable = stack_pointer[-3 - oparg];
            assert(PyStackRef_IsNull(self_or_null));
            _PyStackRef callable_s = callable;
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            assert(Py_TYPE(callable_o) == &PyMethod_Type);
            self_or_null = PyStackRef_FromPyObjectNew(((PyMethodObject *)callable_o)->im_self);
            callable = PyStackRef_FromPyObjectNew(((PyMethodObject *)callable_o)->im_func);
            assert(PyStackRef_FunctionCheck(callable));
            stack_pointer[-3 - oparg] = callable;
            stack_pointer[-2 - oparg] = self_or_null;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable_s);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_IS_NOT_PY_CALLABLE_KW_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            callable = stack_pointer[-2 - oparg];
            if (PyStackRef_IsTaggedInt(callable)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            if (PyFunction_Check(callable_o)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            if (Py_TYPE(callable_o) == &PyMethod_Type) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(1);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CALL_KW_NON_PY_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef kwnames;
            _PyStackRef *args;
            _PyStackRef self_or_null;
            _PyStackRef callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            kwnames = stack_pointer[-1];
            args = &stack_pointer[-1 - oparg];
            self_or_null = stack_pointer[-2 - oparg];
            callable = stack_pointer[-3 - oparg];
            #if TIER_ONE
            assert(opcode != INSTRUMENTED_CALL);
            #endif
            PyObject *callable_o = PyStackRef_AsPyObjectBorrowNonInt(callable);
            int total_args = oparg;
            _PyStackRef *arguments = args;
            if (!PyStackRef_IsNull(self_or_null)) {
                arguments--;
                total_args++;
            }
            STACKREFS_TO_PYOBJECTS(arguments, total_args, args_o);
            if (CONVERSION_FAILED(args_o)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                _PyStackRef tmp = kwnames;
                kwnames = PyStackRef_NULL;
                stack_pointer[-1] = kwnames;
                PyStackRef_CLOSE(tmp);
                for (int _i = oparg; --_i >= 0;) {
                    tmp = args[_i];
                    args[_i] = PyStackRef_NULL;
                    PyStackRef_CLOSE(tmp);
                }
                tmp = self_or_null;
                self_or_null = PyStackRef_NULL;
                stack_pointer[-2 - oparg] = self_or_null;
                PyStackRef_XCLOSE(tmp);
                tmp = callable;
                callable = PyStackRef_NULL;
                stack_pointer[-3 - oparg] = callable;
                PyStackRef_CLOSE(tmp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -3 - oparg;
                assert(WITHIN_STACK_BOUNDS());
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            PyObject *kwnames_o = PyStackRef_AsPyObjectBorrowNonInt(kwnames);
            int positional_args = total_args - (int)PyTuple_GET_SIZE(kwnames_o);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = PyObject_Vectorcall(
                callable_o, args_o,
                positional_args | PY_VECTORCALL_ARGUMENTS_OFFSET,
                kwnames_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(kwnames);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            STACKREFS_TO_PYOBJECTS_CLEANUP(args_o);
            assert((res_o != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp;
            for (int _i = oparg; --_i >= 0;) {
                tmp = args[_i];
                args[_i] = PyStackRef_NULL;
                PyStackRef_CLOSE(tmp);
            }
            tmp = self_or_null;
            self_or_null = PyStackRef_NULL;
            stack_pointer[-1 - oparg] = self_or_null;
            PyStackRef_XCLOSE(tmp);
            tmp = callable;
            callable = PyStackRef_NULL;
            stack_pointer[-2 - oparg] = callable;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _MAKE_CALLARGS_A_TUPLE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef callargs;
            _PyStackRef func;
            callargs = stack_pointer[-2];
            func = stack_pointer[-4];
            if (!PyStackRef_TupleCheckExact(callargs)) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                int err = _Py_Check_ArgsIterable(tstate, func, callargs);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (err < 0) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                PyObject *callargs_o = PyStackRef_AsPyObjectBorrowNonInt(callargs);
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyObject *tuple_o = PySequence_Tuple(callargs_o);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (tuple_o == NULL) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                _PyStackRef temp = callargs;
                callargs = PyStackRef_FromPyObjectSteal(tuple_o);
                stack_pointer[-2] = callargs;
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(temp);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            stack_pointer[-2] = callargs;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        /* _DO_CALL_FUNCTION_EX is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _MAKE_FUNCTION_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef codeobj_st;
            _PyStackRef func;
            codeobj_st = stack_pointer[-1];
            PyObject *codeobj = PyStackRef_AsPyObjectBorrowNonInt(codeobj_st);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyFunctionObject *func_obj = (PyFunctionObject *)
            PyFunction_New(codeobj, GLOBALS());
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(codeobj_st);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (func_obj == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            _PyFunction_SetVersion(
                                   func_obj, ((PyCodeObject *)codeobj)->co_version);
            func = PyStackRef_FromPyObjectSteal((PyObject *)func_obj);
            _tos_cache0 = func;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _SET_FUNCTION_ATTRIBUTE_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef func_in;
            _PyStackRef attr_st;
            _PyStackRef func_out;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            func_in = _stack_item_1;
            attr_st = _stack_item_0;
            PyObject *func = PyStackRef_AsPyObjectBorrowNonInt(func_in);
            PyObject *attr = PyStackRef_AsPyObjectSteal(attr_st);
            func_out = func_in;
            assert(PyFunction_Check(func));
            size_t offset = _Py_FunctionAttributeOffsets[oparg];
            assert(offset != 0);
            PyObject **ptr = (PyObject **)(((char *)func) + offset);
            assert(*ptr == NULL);
            *ptr = attr;
            _tos_cache0 = func_out;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _RETURN_GENERATOR_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef res;
            assert(PyStackRef_FunctionCheck(frame->f_funcobj));
            PyFunctionObject *func = (PyFunctionObject *)PyStackRef_AsPyObjectBorrowNonInt(frame->f_funcobj);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyGenObject *gen = (PyGenObject *)_Py_MakeCoro(func);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (gen == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            assert(STACK_LEVEL() == 0);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyInterpreterFrame *gen_frame = &gen->gi_iframe;
            frame->instr_ptr++;
            _PyFrame_Copy(frame, gen_frame);
            assert(frame->frame_obj == NULL);
            gen->gi_frame_state = FRAME_CREATED;
            gen_frame->owner = FRAME_OWNED_BY_GENERATOR;
            _Py_LeaveRecursiveCallPy(tstate);
            _PyInterpreterFrame *prev = frame->previous;
            _PyThreadState_PopFrame(tstate, frame);
            frame = tstate->current_frame = prev;
            LOAD_IP(frame->return_offset);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            res = PyStackRef_FromPyObjectStealMortal((PyObject *)gen);
            LLTRACE_RESUME_FRAME();
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BUILD_SLICE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef *args;
            _PyStackRef slice;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            PyObject *start_o = PyStackRef_AsPyObjectBorrowed(&args[0]);
            PyObject *stop_o = PyStackRef_AsPyObjectBorrowed(&args[1]);
            PyObject *step_o = oparg == 3 ? PyStackRef_AsPyObjectBorrowed(&args[2]) : NULL;
            PyObject *slice_o = PySlice_New(start_o, stop_o, step_o);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp;
            for (int _i = oparg; --_i >= 0;) {
                tmp = args[_i];
                args[_i] = PyStackRef_NULL;
                PyStackRef_CLOSE(tmp);
            }
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -oparg;
            assert(WITHIN_STACK_BOUNDS());
            if (slice_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            slice = PyStackRef_FromPyObjectStealMortal(slice_o);
            _tos_cache0 = slice;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CONVERT_VALUE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            _PyStackRef result;
            oparg = CURRENT_OPARG();
            value = stack_pointer[-1];
            conversion_func conv_fn;
            assert(oparg >= FVC_STR && oparg <= FVC_ASCII);
            conv_fn = _PyEval_ConversionFuncs[oparg];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *result_o = conv_fn(PyStackRef_AsPyObjectBorrowed(&value));
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(value);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (result_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            result = PyStackRef_FromPyObjectSteal(result_o);
            _tos_cache0 = result;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _FORMAT_SIMPLE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            _PyStackRef res;
            value = stack_pointer[-1];
            if (!PyStackRef_UnicodeCheckExact(value)) {
                PyObject *value_o = PyStackRef_AsPyObjectBorrowed(&value);
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyObject *res_o = PyObject_Format(value_o, NULL);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(value);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (res_o == NULL) {
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_ERROR();
                }
                res = PyStackRef_FromPyObjectSteal(res_o);
            }
            else {
                res = value;
                stack_pointer += -1;
            }
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _FORMAT_WITH_SPEC_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef fmt_spec;
            _PyStackRef value;
            _PyStackRef res;
            fmt_spec = stack_pointer[-1];
            value = stack_pointer[-2];
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = PyObject_Format(PyStackRef_AsPyObjectBorrowed(&value), PyStackRef_AsPyObjectBorrowed(&fmt_spec));
            _PyStackRef tmp = fmt_spec;
            fmt_spec = PyStackRef_NULL;
            stack_pointer[-1] = fmt_spec;
            PyStackRef_CLOSE(tmp);
            tmp = value;
            value = PyStackRef_NULL;
            stack_pointer[-2] = value;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _tos_cache0 = res;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _COPY_1_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef bottom;
            _PyStackRef top;
            _PyStackRef _stack_item_0 = _tos_cache0;
            bottom = _stack_item_0;
            top = PyStackRef_DUP(bottom);
            _tos_cache1 = top;
            _tos_cache0 = bottom;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _COPY_1_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef bottom;
            _PyStackRef top;
            bottom = stack_pointer[-1];
            top = PyStackRef_DUP(bottom);
            _tos_cache0 = top;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _COPY_1_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef bottom;
            _PyStackRef top;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            bottom = _stack_item_1;
            top = PyStackRef_DUP(bottom);
            _tos_cache2 = top;
            _tos_cache1 = bottom;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _COPY_2_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef bottom;
            _PyStackRef top;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            bottom = _stack_item_0;
            top = PyStackRef_DUP(bottom);
            _tos_cache2 = top;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = bottom;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _COPY_3_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef bottom;
            _PyStackRef top;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            bottom = _stack_item_0;
            top = PyStackRef_DUP(bottom);
            _tos_cache2 = top;
            _tos_cache1 = _stack_item_2;
            _tos_cache0 = _stack_item_1;
            stack_pointer[0] = bottom;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _COPY_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef bottom;
            _PyStackRef top;
            oparg = CURRENT_OPARG();
            bottom = stack_pointer[-1 - (oparg-1)];
            top = PyStackRef_DUP(bottom);
            _tos_cache0 = top;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _BINARY_OP_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef rhs;
            _PyStackRef lhs;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            rhs = stack_pointer[-1];
            lhs = stack_pointer[-2];
            PyObject *lhs_o = PyStackRef_AsPyObjectBorrowed(&lhs);
            PyObject *rhs_o = PyStackRef_AsPyObjectBorrowed(&rhs);
            assert(_PyEval_BinaryOps[oparg]);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyObject *res_o = _PyEval_BinaryOps[oparg](lhs_o, rhs_o);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (res_o == NULL) {
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_ERROR();
            }
            res = PyStackRef_FromPyObjectSteal(res_o);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyStackRef tmp = lhs;
            lhs = res;
            stack_pointer[-2] = lhs;
            PyStackRef_CLOSE(tmp);
            tmp = rhs;
            rhs = PyStackRef_NULL;
            stack_pointer[-1] = rhs;
            PyStackRef_CLOSE(tmp);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _tos_cache0 = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _SWAP_2_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef top;
            _PyStackRef bottom;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            top = _stack_item_1;
            bottom = _stack_item_0;
            _PyStackRef temp = bottom;
            bottom = top;
            top = temp;
            _tos_cache1 = top;
            _tos_cache0 = bottom;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _SWAP_2_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef top;
            _PyStackRef bottom;
            top = stack_pointer[-1];
            bottom = stack_pointer[-2];
            _PyStackRef temp = bottom;
            bottom = top;
            top = temp;
            stack_pointer[-2] = bottom;
            stack_pointer[-1] = top;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _SWAP_2_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef top;
            _PyStackRef bottom;
            _PyStackRef _stack_item_0 = _tos_cache0;
            top = _stack_item_0;
            bottom = stack_pointer[-1];
            _PyStackRef temp = bottom;
            bottom = top;
            top = temp;
            _tos_cache0 = top;
            stack_pointer[-1] = bottom;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _SWAP_2_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef top;
            _PyStackRef bottom;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            top = _stack_item_2;
            bottom = _stack_item_1;
            _PyStackRef temp = bottom;
            bottom = top;
            top = temp;
            _tos_cache2 = top;
            _tos_cache1 = bottom;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _SWAP_3_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef top;
            _PyStackRef bottom;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            top = _stack_item_2;
            bottom = _stack_item_0;
            _PyStackRef temp = bottom;
            bottom = top;
            top = temp;
            _tos_cache2 = top;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = bottom;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _SWAP_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef top;
            _PyStackRef bottom;
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            top = _stack_item_0;
            bottom = stack_pointer[-1 - (oparg-2)];
            _PyStackRef temp = bottom;
            bottom = top;
            top = temp;
            _tos_cache0 = top;
            stack_pointer[-1 - (oparg-2)] = bottom;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        /* _INSTRUMENTED_LINE is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_INSTRUCTION is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_JUMP_FORWARD is not a viable micro-op for tier 2 because it is instrumented */

        /* _MONITOR_JUMP_BACKWARD is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        /* _INSTRUMENTED_NOT_TAKEN is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_POP_JUMP_IF_NONE is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_POP_JUMP_IF_NOT_NONE is not a viable micro-op for tier 2 because it is instrumented */

        case _GUARD_IS_TRUE_POP_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef flag;
            _PyStackRef _stack_item_0 = _tos_cache0;
            flag = _stack_item_0;
            int is_true = PyStackRef_IsTrue(flag);
            if (!is_true) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_IS_FALSE_POP_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef flag;
            _PyStackRef _stack_item_0 = _tos_cache0;
            flag = _stack_item_0;
            int is_false = PyStackRef_IsFalse(flag);
            if (!is_false) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_IS_NONE_POP_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef val;
            _PyStackRef _stack_item_0 = _tos_cache0;
            val = _stack_item_0;
            int is_none = PyStackRef_IsNone(val);
            if (!is_none) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                PyStackRef_CLOSE(val);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (1) {
                    UOP_STAT_INC(uopcode, miss);
                    SET_CURRENT_CACHED_VALUES(0);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _GUARD_IS_NOT_NONE_POP_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef val;
            _PyStackRef _stack_item_0 = _tos_cache0;
            val = _stack_item_0;
            int is_none = PyStackRef_IsNone(val);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(val);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            if (is_none) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _JUMP_TO_TOP_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            JUMP_TO_JUMP_TARGET();
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _SET_IP_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            PyObject *instr_ptr = (PyObject *)CURRENT_OPERAND0();
            frame->instr_ptr = (_Py_CODEUNIT *)instr_ptr;
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _SET_IP_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            PyObject *instr_ptr = (PyObject *)CURRENT_OPERAND0();
            frame->instr_ptr = (_Py_CODEUNIT *)instr_ptr;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _SET_IP_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            PyObject *instr_ptr = (PyObject *)CURRENT_OPERAND0();
            frame->instr_ptr = (_Py_CODEUNIT *)instr_ptr;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _SET_IP_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            PyObject *instr_ptr = (PyObject *)CURRENT_OPERAND0();
            frame->instr_ptr = (_Py_CODEUNIT *)instr_ptr;
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CHECK_STACK_SPACE_OPERAND_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            uint32_t framesize = (uint32_t)CURRENT_OPERAND0();
            assert(framesize <= INT_MAX);
            if (!_PyThreadState_HasStackSpace(tstate, framesize)) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (tstate->py_recursion_remaining <= 1) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_STACK_SPACE_OPERAND_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            uint32_t framesize = (uint32_t)CURRENT_OPERAND0();
            assert(framesize <= INT_MAX);
            if (!_PyThreadState_HasStackSpace(tstate, framesize)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (tstate->py_recursion_remaining <= 1) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_STACK_SPACE_OPERAND_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            uint32_t framesize = (uint32_t)CURRENT_OPERAND0();
            assert(framesize <= INT_MAX);
            if (!_PyThreadState_HasStackSpace(tstate, framesize)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (tstate->py_recursion_remaining <= 1) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _CHECK_STACK_SPACE_OPERAND_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            uint32_t framesize = (uint32_t)CURRENT_OPERAND0();
            assert(framesize <= INT_MAX);
            if (!_PyThreadState_HasStackSpace(tstate, framesize)) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            if (tstate->py_recursion_remaining <= 1) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _SAVE_RETURN_OFFSET_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            oparg = CURRENT_OPARG();
            #if TIER_ONE
            frame->return_offset = (uint16_t)(next_instr - this_instr);
            #endif
            #if TIER_TWO
            frame->return_offset = oparg;
            #endif
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _SAVE_RETURN_OFFSET_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            oparg = CURRENT_OPARG();
            #if TIER_ONE
            frame->return_offset = (uint16_t)(next_instr - this_instr);
            #endif
            #if TIER_TWO
            frame->return_offset = oparg;
            #endif
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _SAVE_RETURN_OFFSET_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            oparg = CURRENT_OPARG();
            #if TIER_ONE
            frame->return_offset = (uint16_t)(next_instr - this_instr);
            #endif
            #if TIER_TWO
            frame->return_offset = oparg;
            #endif
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _SAVE_RETURN_OFFSET_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            oparg = CURRENT_OPARG();
            #if TIER_ONE
            frame->return_offset = (uint16_t)(next_instr - this_instr);
            #endif
            #if TIER_TWO
            frame->return_offset = oparg;
            #endif
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _EXIT_TRACE_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            PyObject *exit_p = (PyObject *)CURRENT_OPERAND0();
            _PyExitData *exit = (_PyExitData *)exit_p;
            PyCodeObject *code = _PyFrame_GetCode(frame);
            _Py_CODEUNIT *target = _PyFrame_GetBytecode(frame) + exit->target;
            #if defined(Py_DEBUG) && !defined(_Py_JIT)
            OPT_HIST(trace_uop_execution_counter, trace_run_length_hist);
            if (frame->lltrace >= 2) {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                printf("SIDE EXIT: [UOp ");
                _PyUOpPrint(&next_uop[-1]);
                printf(", exit %lu, temp %d, target %d -> %s]\n",
                       exit - current_executor->exits, exit->temperature.value_and_backoff,
                       (int)(target - _PyFrame_GetBytecode(frame)),
                       _PyOpcode_OpName[target->op.code]);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            #endif
            if (exit->executor && !exit->executor->vm_data.valid) {
                exit->temperature = initial_temperature_backoff_counter();
                _PyFrame_SetStackPointer(frame, stack_pointer);
                Py_CLEAR(exit->executor);
                stack_pointer = _PyFrame_GetStackPointer(frame);
            }
            if (exit->executor == NULL) {
                _Py_BackoffCounter temperature = exit->temperature;
                if (!backoff_counter_triggers(temperature)) {
                    exit->temperature = advance_backoff_counter(temperature);
                    GOTO_TIER_ONE(target);
                    Py_UNREACHABLE();}
                _PyExecutorObject *executor;
                if (target->op.code == ENTER_EXECUTOR) {
                    executor = code->co_executors->executors[target->op.arg];
                    Py_INCREF(executor);
                }
                else {
                    int chain_depth = current_executor->vm_data.chain_depth + 1;
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    int optimized = _PyOptimizer_Optimize(frame, target, &executor, chain_depth);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                    if (optimized <= 0) {
                        exit->temperature = restart_backoff_counter(temperature);
                        GOTO_TIER_ONE(optimized < 0 ? NULL : target);
                        Py_UNREACHABLE();}
                    exit->temperature = initial_temperature_backoff_counter();
                }
                exit->executor = executor;
            }
            GOTO_TIER_TWO(exit->executor);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _EXIT_TRACE_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            PyObject *exit_p = (PyObject *)CURRENT_OPERAND0();
            _PyExitData *exit = (_PyExitData *)exit_p;
            PyCodeObject *code = _PyFrame_GetCode(frame);
            _Py_CODEUNIT *target = _PyFrame_GetBytecode(frame) + exit->target;
            #if defined(Py_DEBUG) && !defined(_Py_JIT)
            OPT_HIST(trace_uop_execution_counter, trace_run_length_hist);
            if (frame->lltrace >= 2) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                printf("SIDE EXIT: [UOp ");
                _PyUOpPrint(&next_uop[-1]);
                printf(", exit %lu, temp %d, target %d -> %s]\n",
                       exit - current_executor->exits, exit->temperature.value_and_backoff,
                       (int)(target - _PyFrame_GetBytecode(frame)),
                       _PyOpcode_OpName[target->op.code]);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
            }
            #endif
            if (exit->executor && !exit->executor->vm_data.valid) {
                exit->temperature = initial_temperature_backoff_counter();
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                Py_CLEAR(exit->executor);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -1;
            }
            if (exit->executor == NULL) {
                _Py_BackoffCounter temperature = exit->temperature;
                if (!backoff_counter_triggers(temperature)) {
                    exit->temperature = advance_backoff_counter(temperature);
                    stack_pointer[0] = _stack_item_0;
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                    GOTO_TIER_ONE(target);
                    Py_UNREACHABLE();}
                _PyExecutorObject *executor;
                if (target->op.code == ENTER_EXECUTOR) {
                    executor = code->co_executors->executors[target->op.arg];
                    Py_INCREF(executor);
                }
                else {
                    int chain_depth = current_executor->vm_data.chain_depth + 1;
                    stack_pointer[0] = _stack_item_0;
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    int optimized = _PyOptimizer_Optimize(frame, target, &executor, chain_depth);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                    if (optimized <= 0) {
                        exit->temperature = restart_backoff_counter(temperature);
                        GOTO_TIER_ONE(optimized < 0 ? NULL : target);
                        Py_UNREACHABLE();}
                    exit->temperature = initial_temperature_backoff_counter();
                    stack_pointer += -1;
                }
                exit->executor = executor;
            }
            stack_pointer[0] = _stack_item_0;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            GOTO_TIER_TWO(exit->executor);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _EXIT_TRACE_r20: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            PyObject *exit_p = (PyObject *)CURRENT_OPERAND0();
            _PyExitData *exit = (_PyExitData *)exit_p;
            PyCodeObject *code = _PyFrame_GetCode(frame);
            _Py_CODEUNIT *target = _PyFrame_GetBytecode(frame) + exit->target;
            #if defined(Py_DEBUG) && !defined(_Py_JIT)
            OPT_HIST(trace_uop_execution_counter, trace_run_length_hist);
            if (frame->lltrace >= 2) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                printf("SIDE EXIT: [UOp ");
                _PyUOpPrint(&next_uop[-1]);
                printf(", exit %lu, temp %d, target %d -> %s]\n",
                       exit - current_executor->exits, exit->temperature.value_and_backoff,
                       (int)(target - _PyFrame_GetBytecode(frame)),
                       _PyOpcode_OpName[target->op.code]);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -2;
            }
            #endif
            if (exit->executor && !exit->executor->vm_data.valid) {
                exit->temperature = initial_temperature_backoff_counter();
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                Py_CLEAR(exit->executor);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -2;
            }
            if (exit->executor == NULL) {
                _Py_BackoffCounter temperature = exit->temperature;
                if (!backoff_counter_triggers(temperature)) {
                    exit->temperature = advance_backoff_counter(temperature);
                    stack_pointer[0] = _stack_item_0;
                    stack_pointer[1] = _stack_item_1;
                    stack_pointer += 2;
                    assert(WITHIN_STACK_BOUNDS());
                    GOTO_TIER_ONE(target);
                    Py_UNREACHABLE();}
                _PyExecutorObject *executor;
                if (target->op.code == ENTER_EXECUTOR) {
                    executor = code->co_executors->executors[target->op.arg];
                    Py_INCREF(executor);
                }
                else {
                    int chain_depth = current_executor->vm_data.chain_depth + 1;
                    stack_pointer[0] = _stack_item_0;
                    stack_pointer[1] = _stack_item_1;
                    stack_pointer += 2;
                    assert(WITHIN_STACK_BOUNDS());
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    int optimized = _PyOptimizer_Optimize(frame, target, &executor, chain_depth);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                    if (optimized <= 0) {
                        exit->temperature = restart_backoff_counter(temperature);
                        GOTO_TIER_ONE(optimized < 0 ? NULL : target);
                        Py_UNREACHABLE();}
                    exit->temperature = initial_temperature_backoff_counter();
                    stack_pointer += -2;
                }
                exit->executor = executor;
            }
            stack_pointer[0] = _stack_item_0;
            stack_pointer[1] = _stack_item_1;
            stack_pointer += 2;
            assert(WITHIN_STACK_BOUNDS());
            GOTO_TIER_TWO(exit->executor);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _EXIT_TRACE_r30: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            PyObject *exit_p = (PyObject *)CURRENT_OPERAND0();
            _PyExitData *exit = (_PyExitData *)exit_p;
            PyCodeObject *code = _PyFrame_GetCode(frame);
            _Py_CODEUNIT *target = _PyFrame_GetBytecode(frame) + exit->target;
            #if defined(Py_DEBUG) && !defined(_Py_JIT)
            OPT_HIST(trace_uop_execution_counter, trace_run_length_hist);
            if (frame->lltrace >= 2) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                printf("SIDE EXIT: [UOp ");
                _PyUOpPrint(&next_uop[-1]);
                printf(", exit %lu, temp %d, target %d -> %s]\n",
                       exit - current_executor->exits, exit->temperature.value_and_backoff,
                       (int)(target - _PyFrame_GetBytecode(frame)),
                       _PyOpcode_OpName[target->op.code]);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -3;
            }
            #endif
            if (exit->executor && !exit->executor->vm_data.valid) {
                exit->temperature = initial_temperature_backoff_counter();
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                _PyFrame_SetStackPointer(frame, stack_pointer);
                Py_CLEAR(exit->executor);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                stack_pointer += -3;
            }
            if (exit->executor == NULL) {
                _Py_BackoffCounter temperature = exit->temperature;
                if (!backoff_counter_triggers(temperature)) {
                    exit->temperature = advance_backoff_counter(temperature);
                    stack_pointer[0] = _stack_item_0;
                    stack_pointer[1] = _stack_item_1;
                    stack_pointer[2] = _stack_item_2;
                    stack_pointer += 3;
                    assert(WITHIN_STACK_BOUNDS());
                    GOTO_TIER_ONE(target);
                    Py_UNREACHABLE();}
                _PyExecutorObject *executor;
                if (target->op.code == ENTER_EXECUTOR) {
                    executor = code->co_executors->executors[target->op.arg];
                    Py_INCREF(executor);
                }
                else {
                    int chain_depth = current_executor->vm_data.chain_depth + 1;
                    stack_pointer[0] = _stack_item_0;
                    stack_pointer[1] = _stack_item_1;
                    stack_pointer[2] = _stack_item_2;
                    stack_pointer += 3;
                    assert(WITHIN_STACK_BOUNDS());
                    _PyFrame_SetStackPointer(frame, stack_pointer);
                    int optimized = _PyOptimizer_Optimize(frame, target, &executor, chain_depth);
                    stack_pointer = _PyFrame_GetStackPointer(frame);
                    if (optimized <= 0) {
                        exit->temperature = restart_backoff_counter(temperature);
                        GOTO_TIER_ONE(optimized < 0 ? NULL : target);
                        Py_UNREACHABLE();}
                    exit->temperature = initial_temperature_backoff_counter();
                    stack_pointer += -3;
                }
                exit->executor = executor;
            }
            stack_pointer[0] = _stack_item_0;
            stack_pointer[1] = _stack_item_1;
            stack_pointer[2] = _stack_item_2;
            stack_pointer += 3;
            assert(WITHIN_STACK_BOUNDS());
            GOTO_TIER_TWO(exit->executor);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_VALIDITY_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            if (!current_executor->vm_data.valid) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_VALIDITY_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            if (!current_executor->vm_data.valid) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_VALIDITY_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            if (!current_executor->vm_data.valid) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _CHECK_VALIDITY_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            if (!current_executor->vm_data.valid) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_CONST_INLINE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            value = PyStackRef_FromPyObjectNew(ptr);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_CONST_INLINE_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            value = PyStackRef_FromPyObjectNew(ptr);
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_CONST_INLINE_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            value = PyStackRef_FromPyObjectNew(ptr);
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _POP_TOP_LOAD_CONST_INLINE_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef pop;
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            pop = _stack_item_0;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(pop);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            value = PyStackRef_FromPyObjectNew(ptr);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_CONST_INLINE_BORROW_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef value;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            value = PyStackRef_FromPyObjectBorrow(ptr);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_CONST_INLINE_BORROW_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            value = PyStackRef_FromPyObjectBorrow(ptr);
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_CONST_INLINE_BORROW_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            value = PyStackRef_FromPyObjectBorrow(ptr);
            _tos_cache2 = value;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _POP_CALL_r20: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            null = _stack_item_1;
            callable = _stack_item_0;
            (void)null;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _POP_CALL_ONE_r30: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef pop;
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            pop = _stack_item_2;
            null = _stack_item_1;
            callable = _stack_item_0;
            stack_pointer[0] = callable;
            stack_pointer[1] = null;
            stack_pointer += 2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(pop);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            (void)null;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _POP_CALL_TWO_r30: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef pop2;
            _PyStackRef pop1;
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            pop2 = _stack_item_2;
            pop1 = _stack_item_1;
            null = _stack_item_0;
            callable = stack_pointer[-1];
            stack_pointer[0] = null;
            stack_pointer[1] = pop1;
            stack_pointer += 2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(pop2);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(pop1);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            (void)null;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _POP_TOP_LOAD_CONST_INLINE_BORROW_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef pop;
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            pop = _stack_item_0;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(pop);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            value = PyStackRef_FromPyObjectBorrow(ptr);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _POP_TWO_LOAD_CONST_INLINE_BORROW_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef pop2;
            _PyStackRef pop1;
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            pop2 = _stack_item_1;
            pop1 = _stack_item_0;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            stack_pointer[0] = pop1;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(pop2);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(pop1);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            value = PyStackRef_FromPyObjectBorrow(ptr);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _POP_CALL_LOAD_CONST_INLINE_BORROW_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            null = _stack_item_1;
            callable = _stack_item_0;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            (void)null;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            value = PyStackRef_FromPyObjectBorrow(ptr);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _POP_CALL_ONE_LOAD_CONST_INLINE_BORROW_r31: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef pop;
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            pop = _stack_item_2;
            null = _stack_item_1;
            callable = _stack_item_0;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            stack_pointer[0] = callable;
            stack_pointer[1] = null;
            stack_pointer += 2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(pop);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            (void)null;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            value = PyStackRef_FromPyObjectBorrow(ptr);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _POP_CALL_TWO_LOAD_CONST_INLINE_BORROW_r31: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef pop2;
            _PyStackRef pop1;
            _PyStackRef null;
            _PyStackRef callable;
            _PyStackRef value;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            pop2 = _stack_item_2;
            pop1 = _stack_item_1;
            null = _stack_item_0;
            callable = stack_pointer[-1];
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            stack_pointer[0] = null;
            stack_pointer[1] = pop1;
            stack_pointer += 2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(pop2);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(pop1);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            (void)null;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            PyStackRef_CLOSE(callable);
            stack_pointer = _PyFrame_GetStackPointer(frame);
            value = PyStackRef_FromPyObjectBorrow(ptr);
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_CONST_UNDER_INLINE_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef old;
            _PyStackRef value;
            _PyStackRef new;
            _PyStackRef _stack_item_0 = _tos_cache0;
            old = _stack_item_0;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            new = old;
            value = PyStackRef_FromPyObjectNew(ptr);
            _tos_cache1 = new;
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_CONST_UNDER_INLINE_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef old;
            _PyStackRef value;
            _PyStackRef new;
            old = stack_pointer[-1];
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            new = old;
            value = PyStackRef_FromPyObjectNew(ptr);
            _tos_cache0 = new;
            stack_pointer[-1] = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_CONST_UNDER_INLINE_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef old;
            _PyStackRef value;
            _PyStackRef new;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            old = _stack_item_1;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            new = old;
            value = PyStackRef_FromPyObjectNew(ptr);
            _tos_cache2 = new;
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _LOAD_CONST_UNDER_INLINE_BORROW_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef old;
            _PyStackRef value;
            _PyStackRef new;
            _PyStackRef _stack_item_0 = _tos_cache0;
            old = _stack_item_0;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            new = old;
            value = PyStackRef_FromPyObjectBorrow(ptr);
            _tos_cache1 = new;
            _tos_cache0 = value;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _LOAD_CONST_UNDER_INLINE_BORROW_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _PyStackRef old;
            _PyStackRef value;
            _PyStackRef new;
            old = stack_pointer[-1];
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            new = old;
            value = PyStackRef_FromPyObjectBorrow(ptr);
            _tos_cache0 = new;
            stack_pointer[-1] = value;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _LOAD_CONST_UNDER_INLINE_BORROW_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef old;
            _PyStackRef value;
            _PyStackRef new;
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            old = _stack_item_1;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND0();
            new = old;
            value = PyStackRef_FromPyObjectBorrow(ptr);
            _tos_cache2 = new;
            _tos_cache1 = value;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _CHECK_FUNCTION_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            assert(PyStackRef_FunctionCheck(frame->f_funcobj));
            PyFunctionObject *func = (PyFunctionObject *)PyStackRef_AsPyObjectBorrowNonInt(frame->f_funcobj);
            if (func->func_version != func_version) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _CHECK_FUNCTION_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            assert(PyStackRef_FunctionCheck(frame->f_funcobj));
            PyFunctionObject *func = (PyFunctionObject *)PyStackRef_AsPyObjectBorrowNonInt(frame->f_funcobj);
            if (func->func_version != func_version) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _CHECK_FUNCTION_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            assert(PyStackRef_FunctionCheck(frame->f_funcobj));
            PyFunctionObject *func = (PyFunctionObject *)PyStackRef_AsPyObjectBorrowNonInt(frame->f_funcobj);
            if (func->func_version != func_version) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _CHECK_FUNCTION_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            uint32_t func_version = (uint32_t)CURRENT_OPERAND0();
            assert(PyStackRef_FunctionCheck(frame->f_funcobj));
            PyFunctionObject *func = (PyFunctionObject *)PyStackRef_AsPyObjectBorrowNonInt(frame->f_funcobj);
            if (func->func_version != func_version) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _START_EXECUTOR_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            PyObject *executor = (PyObject *)CURRENT_OPERAND0();
            #ifndef _Py_JIT
            current_executor = (_PyExecutorObject*)executor;
            #endif
            assert(((_PyExecutorObject *)executor)->vm_data.valid);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _MAKE_WARM_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            current_executor->vm_data.warm = true;
            if (--tstate->interp->trace_run_counter == 0) {
                _Py_set_eval_breaker_bit(tstate, _PY_EVAL_JIT_INVALIDATE_COLD_BIT);
            }
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _MAKE_WARM_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            current_executor->vm_data.warm = true;
            if (--tstate->interp->trace_run_counter == 0) {
                _Py_set_eval_breaker_bit(tstate, _PY_EVAL_JIT_INVALIDATE_COLD_BIT);
            }
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _MAKE_WARM_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            current_executor->vm_data.warm = true;
            if (--tstate->interp->trace_run_counter == 0) {
                _Py_set_eval_breaker_bit(tstate, _PY_EVAL_JIT_INVALIDATE_COLD_BIT);
            }
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _MAKE_WARM_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            current_executor->vm_data.warm = true;
            if (--tstate->interp->trace_run_counter == 0) {
                _Py_set_eval_breaker_bit(tstate, _PY_EVAL_JIT_INVALIDATE_COLD_BIT);
            }
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _FATAL_ERROR_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            assert(0);
            Py_FatalError("Fatal error uop executed.");
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _FATAL_ERROR_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            assert(0);
            Py_FatalError("Fatal error uop executed.");
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _FATAL_ERROR_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            assert(0);
            Py_FatalError("Fatal error uop executed.");
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _FATAL_ERROR_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            assert(0);
            Py_FatalError("Fatal error uop executed.");
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _DEOPT_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            GOTO_TIER_ONE(_PyFrame_GetBytecode(frame) + CURRENT_TARGET());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _ERROR_POP_N_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            oparg = CURRENT_OPARG();
            uint32_t target = (uint32_t)CURRENT_OPERAND0();
            assert(oparg == 0);
            frame->instr_ptr = _PyFrame_GetBytecode(frame) + target;
            GOTO_TIER_ONE(NULL);
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _TIER2_RESUME_CHECK_r00: {
            CHECK_CURRENT_CACHED_VALUES(0);
            #if defined(__EMSCRIPTEN__)
            if (_Py_emscripten_signal_clock == 0) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _Py_emscripten_signal_clock -= Py_EMSCRIPTEN_SIGNAL_HANDLING;
            #endif
            uintptr_t eval_breaker = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker);
            if (eval_breaker & _PY_EVAL_EVENTS_MASK) {
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(tstate->tracing || eval_breaker == FT_ATOMIC_LOAD_UINTPTR_ACQUIRE(_PyFrame_GetCode(frame)->_co_instrumentation_version));
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _TIER2_RESUME_CHECK_r11: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            #if defined(__EMSCRIPTEN__)
            if (_Py_emscripten_signal_clock == 0) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _Py_emscripten_signal_clock -= Py_EMSCRIPTEN_SIGNAL_HANDLING;
            #endif
            uintptr_t eval_breaker = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker);
            if (eval_breaker & _PY_EVAL_EVENTS_MASK) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(tstate->tracing || eval_breaker == FT_ATOMIC_LOAD_UINTPTR_ACQUIRE(_PyFrame_GetCode(frame)->_co_instrumentation_version));
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _TIER2_RESUME_CHECK_r22: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            #if defined(__EMSCRIPTEN__)
            if (_Py_emscripten_signal_clock == 0) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _Py_emscripten_signal_clock -= Py_EMSCRIPTEN_SIGNAL_HANDLING;
            #endif
            uintptr_t eval_breaker = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker);
            if (eval_breaker & _PY_EVAL_EVENTS_MASK) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(tstate->tracing || eval_breaker == FT_ATOMIC_LOAD_UINTPTR_ACQUIRE(_PyFrame_GetCode(frame)->_co_instrumentation_version));
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _TIER2_RESUME_CHECK_r33: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            #if defined(__EMSCRIPTEN__)
            if (_Py_emscripten_signal_clock == 0) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            _Py_emscripten_signal_clock -= Py_EMSCRIPTEN_SIGNAL_HANDLING;
            #endif
            uintptr_t eval_breaker = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker);
            if (eval_breaker & _PY_EVAL_EVENTS_MASK) {
                stack_pointer[0] = _stack_item_0;
                stack_pointer[1] = _stack_item_1;
                stack_pointer[2] = _stack_item_2;
                stack_pointer += 3;
                assert(WITHIN_STACK_BOUNDS());
                UOP_STAT_INC(uopcode, miss);
                SET_CURRENT_CACHED_VALUES(0);
                JUMP_TO_JUMP_TARGET();
            }
            assert(tstate->tracing || eval_breaker == FT_ATOMIC_LOAD_UINTPTR_ACQUIRE(_PyFrame_GetCode(frame)->_co_instrumentation_version));
            _tos_cache2 = _stack_item_2;
            _tos_cache1 = _stack_item_1;
            _tos_cache0 = _stack_item_0;
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _SPILL_OR_RELOAD_r01: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _tos_cache0 = stack_pointer[-1];
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _SPILL_OR_RELOAD_r02: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _tos_cache1 = stack_pointer[-1];
            _tos_cache0 = stack_pointer[-2];
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _SPILL_OR_RELOAD_r03: {
            CHECK_CURRENT_CACHED_VALUES(0);
            _tos_cache2 = stack_pointer[-1];
            _tos_cache1 = stack_pointer[-2];
            _tos_cache0 = stack_pointer[-3];
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _SPILL_OR_RELOAD_r10: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            stack_pointer[0] = _stack_item_0;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _SPILL_OR_RELOAD_r12: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _tos_cache1 = _stack_item_0;
            _tos_cache0 = stack_pointer[-1];
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

        case _SPILL_OR_RELOAD_r13: {
            CHECK_CURRENT_CACHED_VALUES(1);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _tos_cache2 = _stack_item_0;
            _tos_cache1 = stack_pointer[-1];
            _tos_cache0 = stack_pointer[-2];
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _SPILL_OR_RELOAD_r20: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            stack_pointer[0] = _stack_item_0;
            stack_pointer[1] = _stack_item_1;
            stack_pointer += 2;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _SPILL_OR_RELOAD_r21: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _tos_cache0 = _stack_item_1;
            stack_pointer[0] = _stack_item_0;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _SPILL_OR_RELOAD_r23: {
            CHECK_CURRENT_CACHED_VALUES(2);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _tos_cache2 = _stack_item_1;
            _tos_cache1 = _stack_item_0;
            _tos_cache0 = stack_pointer[-1];
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(3);
            break;
        }

        case _SPILL_OR_RELOAD_r30: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            stack_pointer[0] = _stack_item_0;
            stack_pointer[1] = _stack_item_1;
            stack_pointer[2] = _stack_item_2;
            stack_pointer += 3;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(0);
            break;
        }

        case _SPILL_OR_RELOAD_r31: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            _tos_cache0 = _stack_item_2;
            stack_pointer[0] = _stack_item_0;
            stack_pointer[1] = _stack_item_1;
            stack_pointer += 2;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(1);
            break;
        }

        case _SPILL_OR_RELOAD_r32: {
            CHECK_CURRENT_CACHED_VALUES(3);
            _PyStackRef _stack_item_0 = _tos_cache0;
            _PyStackRef _stack_item_1 = _tos_cache1;
            _PyStackRef _stack_item_2 = _tos_cache2;
            _tos_cache1 = _stack_item_2;
            _tos_cache0 = _stack_item_1;
            stack_pointer[0] = _stack_item_0;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            SET_CURRENT_CACHED_VALUES(2);
            break;
        }

#undef TIER_TWO
